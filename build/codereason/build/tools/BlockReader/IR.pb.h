// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IR.proto

#ifndef PROTOBUF_IR_2eproto__INCLUDED
#define PROTOBUF_IR_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_IR_2eproto();
void protobuf_AssignDesc_IR_2eproto();
void protobuf_ShutdownFile_IR_2eproto();

class DModule;
class DModule_TArch;
class DModule_ConstantValue;
class DModule_TVar;
class DModule_RegArray;
class DModule_Expression;
class DModule_Register;
class DModule_Statement;
class DModule_DBlock;

enum DModule_TArchMajor {
  DModule_TArchMajor_TA_MA_INVALID = 0,
  DModule_TArchMajor_X86 = 1,
  DModule_TArchMajor_AMD64 = 2,
  DModule_TArchMajor_ARM = 3,
  DModule_TArchMajor_PPC32 = 4,
  DModule_TArchMajor_PPC64 = 5,
  DModule_TArchMajor_S390X = 6
};
bool DModule_TArchMajor_IsValid(int value);
const DModule_TArchMajor DModule_TArchMajor_TArchMajor_MIN = DModule_TArchMajor_TA_MA_INVALID;
const DModule_TArchMajor DModule_TArchMajor_TArchMajor_MAX = DModule_TArchMajor_S390X;
const int DModule_TArchMajor_TArchMajor_ARRAYSIZE = DModule_TArchMajor_TArchMajor_MAX + 1;

const ::google::protobuf::EnumDescriptor* DModule_TArchMajor_descriptor();
inline const ::std::string& DModule_TArchMajor_Name(DModule_TArchMajor value) {
  return ::google::protobuf::internal::NameOfEnum(
    DModule_TArchMajor_descriptor(), value);
}
inline bool DModule_TArchMajor_Parse(
    const ::std::string& name, DModule_TArchMajor* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DModule_TArchMajor>(
    DModule_TArchMajor_descriptor(), name, value);
}
enum DModule_TArchMinor {
  DModule_TArchMinor_TA_MI_INVALID = 0,
  DModule_TArchMinor_WIDEARM = 1,
  DModule_TArchMinor_THUMB = 2
};
bool DModule_TArchMinor_IsValid(int value);
const DModule_TArchMinor DModule_TArchMinor_TArchMinor_MIN = DModule_TArchMinor_TA_MI_INVALID;
const DModule_TArchMinor DModule_TArchMinor_TArchMinor_MAX = DModule_TArchMinor_THUMB;
const int DModule_TArchMinor_TArchMinor_ARRAYSIZE = DModule_TArchMinor_TArchMinor_MAX + 1;

const ::google::protobuf::EnumDescriptor* DModule_TArchMinor_descriptor();
inline const ::std::string& DModule_TArchMinor_Name(DModule_TArchMinor value) {
  return ::google::protobuf::internal::NameOfEnum(
    DModule_TArchMinor_descriptor(), value);
}
inline bool DModule_TArchMinor_Parse(
    const ::std::string& name, DModule_TArchMinor* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DModule_TArchMinor>(
    DModule_TArchMinor_descriptor(), name, value);
}
enum DModule_Ops {
  DModule_Ops_Add = 0,
  DModule_Ops_Sub = 1,
  DModule_Ops_Mul = 2,
  DModule_Ops_MulU = 3,
  DModule_Ops_MulS = 4,
  DModule_Ops_Or = 5,
  DModule_Ops_And = 6,
  DModule_Ops_Xor = 7,
  DModule_Ops_Shl = 8,
  DModule_Ops_Shr = 9,
  DModule_Ops_Sar = 10,
  DModule_Ops_CmpEQ = 11,
  DModule_Ops_CmpNE = 12,
  DModule_Ops_CmpLTS = 13,
  DModule_Ops_CmpLTU = 14,
  DModule_Ops_CmpLES = 15,
  DModule_Ops_CmpLEU = 16,
  DModule_Ops_Not = 17,
  DModule_Ops_CF32toF64 = 18,
  DModule_Ops_C64to8 = 19,
  DModule_Ops_C32to8 = 20,
  DModule_Ops_C64to16 = 21,
  DModule_Ops_C64LOto32 = 22,
  DModule_Ops_C64HIto32 = 23,
  DModule_Ops_C32LOto16 = 24,
  DModule_Ops_C32HIto16 = 25,
  DModule_Ops_C16LOto8 = 26,
  DModule_Ops_C16HIto8 = 27,
  DModule_Ops_C16HLto32 = 28,
  DModule_Ops_C1Uto32 = 29,
  DModule_Ops_C1Uto8 = 30,
  DModule_Ops_C8Uto32 = 31,
  DModule_Ops_C8Sto32 = 32,
  DModule_Ops_C8Uto16 = 33,
  DModule_Ops_C8Sto16 = 34,
  DModule_Ops_C8Uto64 = 35,
  DModule_Ops_C16Uto64 = 36,
  DModule_Ops_C16Uto32 = 37,
  DModule_Ops_C16Sto32 = 38,
  DModule_Ops_C32Uto64 = 39,
  DModule_Ops_C32Sto64 = 40,
  DModule_Ops_C32HLto64 = 41,
  DModule_Ops_C32to1 = 42,
  DModule_Ops_C64to1 = 43,
  DModule_Ops_DivModS64to32 = 44,
  DModule_Ops_DivModU64to32 = 45,
  DModule_Ops_Sad8Ux4 = 46,
  DModule_Ops_Add8x8 = 47,
  DModule_Ops_Add16x4 = 48,
  DModule_Ops_Add32x2 = 49,
  DModule_Ops_Add64x1 = 50,
  DModule_Ops_QAdd8Sx8 = 51,
  DModule_Ops_QAdd16Sx4 = 52,
  DModule_Ops_QAdd32Sx2 = 53,
  DModule_Ops_QAdd64Sx1 = 54,
  DModule_Ops_QAdd8Ux8 = 55,
  DModule_Ops_QAdd16Ux4 = 56,
  DModule_Ops_QAdd32Ux2 = 57,
  DModule_Ops_QAdd64Ux1 = 58,
  DModule_Ops_Sub8x8 = 59,
  DModule_Ops_Sub16x4 = 60,
  DModule_Ops_Sub32x2 = 61,
  DModule_Ops_QSub8Sx8 = 62,
  DModule_Ops_QSub16Sx4 = 63,
  DModule_Ops_QSub32Sx2 = 64,
  DModule_Ops_QSub64Sx1 = 65,
  DModule_Ops_QSub8Ux8 = 66,
  DModule_Ops_QSub16Ux4 = 67,
  DModule_Ops_QSub32Ux2 = 68,
  DModule_Ops_QSub64Ux1 = 69,
  DModule_Ops_CmpEQ8x8 = 70,
  DModule_Ops_CmpEQ16x4 = 71,
  DModule_Ops_CmpEQ32x2 = 72,
  DModule_Ops_CmpGT8Ux8 = 73,
  DModule_Ops_CmpGT16Ux4 = 74,
  DModule_Ops_CmpGT32Ux2 = 75,
  DModule_Ops_CmpGT8Sx8 = 76,
  DModule_Ops_CmpGT16Sx4 = 77,
  DModule_Ops_CmpGT32Sx2 = 78,
  DModule_Ops_ShlN8x8 = 79,
  DModule_Ops_ShlN16x4 = 80,
  DModule_Ops_ShlN32x2 = 81,
  DModule_Ops_ShrN8x8 = 82,
  DModule_Ops_ShrN16x4 = 83,
  DModule_Ops_ShrN32x2 = 84,
  DModule_Ops_SarN8x8 = 85,
  DModule_Ops_SarN16x4 = 86,
  DModule_Ops_SarN32x2 = 87,
  DModule_Ops_Mul8x8 = 88,
  DModule_Ops_Mul16x4 = 89,
  DModule_Ops_Mul32x2 = 90,
  DModule_Ops_Mul32Fx2 = 91,
  DModule_Ops_MulHi16Ux4 = 92,
  DModule_Ops_MulHi16Sx4 = 93,
  DModule_Ops_PolyMul8x8 = 94,
  DModule_Ops_InterleaveHI8x8 = 95,
  DModule_Ops_InterleaveHI16x4 = 96,
  DModule_Ops_InterleaveHI32x2 = 97,
  DModule_Ops_InterleaveLO8x8 = 98,
  DModule_Ops_InterleaveLO16x4 = 99,
  DModule_Ops_InterleaveLO32x2 = 100,
  DModule_Ops_InterleaveOddLanes8x8 = 101,
  DModule_Ops_InterleaveEvenLanes8x8 = 102,
  DModule_Ops_InterleaveOddLanes16x4 = 103,
  DModule_Ops_InterleaveEvenLanes16x4 = 104,
  DModule_Ops_Abs8x16 = 105,
  DModule_Ops_Abs16x8 = 106,
  DModule_Ops_Abs32x4 = 107,
  DModule_Ops_Avg8Ux16 = 108,
  DModule_Ops_Avg16Ux8 = 109,
  DModule_Ops_Avg32Ux4 = 110,
  DModule_Ops_Avg8Sx16 = 111,
  DModule_Ops_Avg16Sx8 = 112,
  DModule_Ops_Avg32Sx4 = 113,
  DModule_Ops_Max8Sx16 = 114,
  DModule_Ops_Max16Sx8 = 115,
  DModule_Ops_Max32Sx4 = 116,
  DModule_Ops_Max8Ux16 = 117,
  DModule_Ops_Max16Ux8 = 118,
  DModule_Ops_Max32Ux4 = 119,
  DModule_Ops_Min8Sx16 = 120,
  DModule_Ops_Min16Sx8 = 121,
  DModule_Ops_Min32Sx4 = 122,
  DModule_Ops_Min8Ux16 = 123,
  DModule_Ops_Min16Ux8 = 124,
  DModule_Ops_Min32Ux4 = 125,
  DModule_Ops_Min8Ux8 = 126,
  DModule_Ops_Min16Ux4 = 127,
  DModule_Ops_Min32Ux2 = 128,
  DModule_Ops_Max8Sx8 = 129,
  DModule_Ops_Max16Sx4 = 130,
  DModule_Ops_Max32Sx2 = 131,
  DModule_Ops_Max8Ux8 = 132,
  DModule_Ops_Max16Ux4 = 133,
  DModule_Ops_Max32Ux2 = 134,
  DModule_Ops_Min8Sx8 = 135,
  DModule_Ops_Min16Sx4 = 136,
  DModule_Ops_Min32Sx2 = 137,
  DModule_Ops_QNarrow16Ux4 = 138,
  DModule_Ops_QNarrow16Sx4 = 139,
  DModule_Ops_QNarrow32Sx2 = 140,
  DModule_Ops_UNSUP = 141
};
bool DModule_Ops_IsValid(int value);
const DModule_Ops DModule_Ops_Ops_MIN = DModule_Ops_Add;
const DModule_Ops DModule_Ops_Ops_MAX = DModule_Ops_UNSUP;
const int DModule_Ops_Ops_ARRAYSIZE = DModule_Ops_Ops_MAX + 1;

const ::google::protobuf::EnumDescriptor* DModule_Ops_descriptor();
inline const ::std::string& DModule_Ops_Name(DModule_Ops value) {
  return ::google::protobuf::internal::NameOfEnum(
    DModule_Ops_descriptor(), value);
}
inline bool DModule_Ops_Parse(
    const ::std::string& name, DModule_Ops* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DModule_Ops>(
    DModule_Ops_descriptor(), name, value);
}
enum DModule_ExType {
  DModule_ExType_Const = 0,
  DModule_ExType_RdTmp = 1,
  DModule_ExType_Op = 2,
  DModule_ExType_Load = 3,
  DModule_ExType_Mux0X = 4,
  DModule_ExType_CCall = 5,
  DModule_ExType_Get = 6
};
bool DModule_ExType_IsValid(int value);
const DModule_ExType DModule_ExType_ExType_MIN = DModule_ExType_Const;
const DModule_ExType DModule_ExType_ExType_MAX = DModule_ExType_Get;
const int DModule_ExType_ExType_ARRAYSIZE = DModule_ExType_ExType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DModule_ExType_descriptor();
inline const ::std::string& DModule_ExType_Name(DModule_ExType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DModule_ExType_descriptor(), value);
}
inline bool DModule_ExType_Parse(
    const ::std::string& name, DModule_ExType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DModule_ExType>(
    DModule_ExType_descriptor(), name, value);
}
enum DModule_ValTy {
  DModule_ValTy_T_INVALID = 0,
  DModule_ValTy_T_I1 = 1,
  DModule_ValTy_T_I8 = 2,
  DModule_ValTy_T_I16 = 3,
  DModule_ValTy_T_I32 = 4,
  DModule_ValTy_T_I64 = 5,
  DModule_ValTy_T_I128 = 6,
  DModule_ValTy_T_F32 = 7,
  DModule_ValTy_T_F64 = 8,
  DModule_ValTy_T_F128 = 9,
  DModule_ValTy_T_V128 = 10
};
bool DModule_ValTy_IsValid(int value);
const DModule_ValTy DModule_ValTy_ValTy_MIN = DModule_ValTy_T_INVALID;
const DModule_ValTy DModule_ValTy_ValTy_MAX = DModule_ValTy_T_V128;
const int DModule_ValTy_ValTy_ARRAYSIZE = DModule_ValTy_ValTy_MAX + 1;

const ::google::protobuf::EnumDescriptor* DModule_ValTy_descriptor();
inline const ::std::string& DModule_ValTy_Name(DModule_ValTy value) {
  return ::google::protobuf::internal::NameOfEnum(
    DModule_ValTy_descriptor(), value);
}
inline bool DModule_ValTy_Parse(
    const ::std::string& name, DModule_ValTy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DModule_ValTy>(
    DModule_ValTy_descriptor(), name, value);
}
enum DModule_StType {
  DModule_StType_WrTmp = 0,
  DModule_StType_Store = 1,
  DModule_StType_CAS = 2,
  DModule_StType_Put = 3,
  DModule_StType_LLSC = 4,
  DModule_StType_Dirty = 5,
  DModule_StType_Exit = 6,
  DModule_StType_IMark = 7,
  DModule_StType_NOP = 8,
  DModule_StType_AbiHint = 9,
  DModule_StType_MBE = 10
};
bool DModule_StType_IsValid(int value);
const DModule_StType DModule_StType_StType_MIN = DModule_StType_WrTmp;
const DModule_StType DModule_StType_StType_MAX = DModule_StType_MBE;
const int DModule_StType_StType_ARRAYSIZE = DModule_StType_StType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DModule_StType_descriptor();
inline const ::std::string& DModule_StType_Name(DModule_StType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DModule_StType_descriptor(), value);
}
inline bool DModule_StType_Parse(
    const ::std::string& name, DModule_StType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DModule_StType>(
    DModule_StType_descriptor(), name, value);
}
enum DModule_ExitType {
  DModule_ExitType_Fallthrough = 0,
  DModule_ExitType_Call = 1,
  DModule_ExitType_Return = 2,
  DModule_ExitType_UnknownExit = 3
};
bool DModule_ExitType_IsValid(int value);
const DModule_ExitType DModule_ExitType_ExitType_MIN = DModule_ExitType_Fallthrough;
const DModule_ExitType DModule_ExitType_ExitType_MAX = DModule_ExitType_UnknownExit;
const int DModule_ExitType_ExitType_ARRAYSIZE = DModule_ExitType_ExitType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DModule_ExitType_descriptor();
inline const ::std::string& DModule_ExitType_Name(DModule_ExitType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DModule_ExitType_descriptor(), value);
}
inline bool DModule_ExitType_Parse(
    const ::std::string& name, DModule_ExitType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DModule_ExitType>(
    DModule_ExitType_descriptor(), name, value);
}
enum DModule_MemoryEnd {
  DModule_MemoryEnd_BigEndian = 0,
  DModule_MemoryEnd_LittleEndian = 1
};
bool DModule_MemoryEnd_IsValid(int value);
const DModule_MemoryEnd DModule_MemoryEnd_MemoryEnd_MIN = DModule_MemoryEnd_BigEndian;
const DModule_MemoryEnd DModule_MemoryEnd_MemoryEnd_MAX = DModule_MemoryEnd_LittleEndian;
const int DModule_MemoryEnd_MemoryEnd_ARRAYSIZE = DModule_MemoryEnd_MemoryEnd_MAX + 1;

const ::google::protobuf::EnumDescriptor* DModule_MemoryEnd_descriptor();
inline const ::std::string& DModule_MemoryEnd_Name(DModule_MemoryEnd value) {
  return ::google::protobuf::internal::NameOfEnum(
    DModule_MemoryEnd_descriptor(), value);
}
inline bool DModule_MemoryEnd_Parse(
    const ::std::string& name, DModule_MemoryEnd* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DModule_MemoryEnd>(
    DModule_MemoryEnd_descriptor(), name, value);
}
enum DModule_RegisterClass {
  DModule_RegisterClass_GenericRegister = 0,
  DModule_RegisterClass_StackPointer = 1,
  DModule_RegisterClass_ProgramCounter = 2,
  DModule_RegisterClass_Flags = 3,
  DModule_RegisterClass_InternalState = 4
};
bool DModule_RegisterClass_IsValid(int value);
const DModule_RegisterClass DModule_RegisterClass_RegisterClass_MIN = DModule_RegisterClass_GenericRegister;
const DModule_RegisterClass DModule_RegisterClass_RegisterClass_MAX = DModule_RegisterClass_InternalState;
const int DModule_RegisterClass_RegisterClass_ARRAYSIZE = DModule_RegisterClass_RegisterClass_MAX + 1;

const ::google::protobuf::EnumDescriptor* DModule_RegisterClass_descriptor();
inline const ::std::string& DModule_RegisterClass_Name(DModule_RegisterClass value) {
  return ::google::protobuf::internal::NameOfEnum(
    DModule_RegisterClass_descriptor(), value);
}
inline bool DModule_RegisterClass_Parse(
    const ::std::string& name, DModule_RegisterClass* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DModule_RegisterClass>(
    DModule_RegisterClass_descriptor(), name, value);
}
enum DModule_x86reg_8 {
  DModule_x86reg_8_AL = 0,
  DModule_x86reg_8_AH = 1,
  DModule_x86reg_8_BL = 2,
  DModule_x86reg_8_BH = 3,
  DModule_x86reg_8_CL = 4,
  DModule_x86reg_8_CH = 5,
  DModule_x86reg_8_DL = 6,
  DModule_x86reg_8_DH = 7
};
bool DModule_x86reg_8_IsValid(int value);
const DModule_x86reg_8 DModule_x86reg_8_x86reg_8_MIN = DModule_x86reg_8_AL;
const DModule_x86reg_8 DModule_x86reg_8_x86reg_8_MAX = DModule_x86reg_8_DH;
const int DModule_x86reg_8_x86reg_8_ARRAYSIZE = DModule_x86reg_8_x86reg_8_MAX + 1;

const ::google::protobuf::EnumDescriptor* DModule_x86reg_8_descriptor();
inline const ::std::string& DModule_x86reg_8_Name(DModule_x86reg_8 value) {
  return ::google::protobuf::internal::NameOfEnum(
    DModule_x86reg_8_descriptor(), value);
}
inline bool DModule_x86reg_8_Parse(
    const ::std::string& name, DModule_x86reg_8* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DModule_x86reg_8>(
    DModule_x86reg_8_descriptor(), name, value);
}
enum DModule_x86reg_16 {
  DModule_x86reg_16_AX = 0,
  DModule_x86reg_16_BX = 1,
  DModule_x86reg_16_CX = 2,
  DModule_x86reg_16_DX = 3,
  DModule_x86reg_16_BP = 4,
  DModule_x86reg_16_SI = 5,
  DModule_x86reg_16_DI = 6,
  DModule_x86reg_16_SP = 7
};
bool DModule_x86reg_16_IsValid(int value);
const DModule_x86reg_16 DModule_x86reg_16_x86reg_16_MIN = DModule_x86reg_16_AX;
const DModule_x86reg_16 DModule_x86reg_16_x86reg_16_MAX = DModule_x86reg_16_SP;
const int DModule_x86reg_16_x86reg_16_ARRAYSIZE = DModule_x86reg_16_x86reg_16_MAX + 1;

const ::google::protobuf::EnumDescriptor* DModule_x86reg_16_descriptor();
inline const ::std::string& DModule_x86reg_16_Name(DModule_x86reg_16 value) {
  return ::google::protobuf::internal::NameOfEnum(
    DModule_x86reg_16_descriptor(), value);
}
inline bool DModule_x86reg_16_Parse(
    const ::std::string& name, DModule_x86reg_16* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DModule_x86reg_16>(
    DModule_x86reg_16_descriptor(), name, value);
}
enum DModule_x86reg_32 {
  DModule_x86reg_32_EAX = 0,
  DModule_x86reg_32_EBX = 1,
  DModule_x86reg_32_ECX = 2,
  DModule_x86reg_32_EDX = 3,
  DModule_x86reg_32_EDI = 4,
  DModule_x86reg_32_ESI = 5,
  DModule_x86reg_32_EBP = 6,
  DModule_x86reg_32_ESP = 7,
  DModule_x86reg_32_EIP = 8,
  DModule_x86reg_32_CS = 9,
  DModule_x86reg_32_DS = 10,
  DModule_x86reg_32_ES = 11,
  DModule_x86reg_32_FS = 12,
  DModule_x86reg_32_GS = 13,
  DModule_x86reg_32_SS = 14,
  DModule_x86reg_32_OP = 15,
  DModule_x86reg_32_DEP1 = 16,
  DModule_x86reg_32_DEP2 = 17,
  DModule_x86reg_32_NDEP = 18,
  DModule_x86reg_32_DFLAG = 19,
  DModule_x86reg_32_IDFLAG = 20,
  DModule_x86reg_32_ACFLAG = 21,
  DModule_x86reg_32_FTOP = 22,
  DModule_x86reg_32_LDT32 = 23,
  DModule_x86reg_32_GDT32 = 24,
  DModule_x86reg_32_EMWARN32 = 25
};
bool DModule_x86reg_32_IsValid(int value);
const DModule_x86reg_32 DModule_x86reg_32_x86reg_32_MIN = DModule_x86reg_32_EAX;
const DModule_x86reg_32 DModule_x86reg_32_x86reg_32_MAX = DModule_x86reg_32_EMWARN32;
const int DModule_x86reg_32_x86reg_32_ARRAYSIZE = DModule_x86reg_32_x86reg_32_MAX + 1;

const ::google::protobuf::EnumDescriptor* DModule_x86reg_32_descriptor();
inline const ::std::string& DModule_x86reg_32_Name(DModule_x86reg_32 value) {
  return ::google::protobuf::internal::NameOfEnum(
    DModule_x86reg_32_descriptor(), value);
}
inline bool DModule_x86reg_32_Parse(
    const ::std::string& name, DModule_x86reg_32* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DModule_x86reg_32>(
    DModule_x86reg_32_descriptor(), name, value);
}
enum DModule_x86reg_64 {
  DModule_x86reg_64_RAX = 0,
  DModule_x86reg_64_RBX = 1,
  DModule_x86reg_64_RCX = 2,
  DModule_x86reg_64_RDX = 3,
  DModule_x86reg_64_RDI = 4,
  DModule_x86reg_64_RSI = 5,
  DModule_x86reg_64_RSP = 6,
  DModule_x86reg_64_RBP = 7,
  DModule_x86reg_64_RIP = 8,
  DModule_x86reg_64_R8 = 9,
  DModule_x86reg_64_R9 = 10,
  DModule_x86reg_64_R10 = 11,
  DModule_x86reg_64_R11 = 12,
  DModule_x86reg_64_R12 = 13,
  DModule_x86reg_64_R13 = 14,
  DModule_x86reg_64_R14 = 15,
  DModule_x86reg_64_R15 = 16,
  DModule_x86reg_64_GDT = 17,
  DModule_x86reg_64_LDT = 18
};
bool DModule_x86reg_64_IsValid(int value);
const DModule_x86reg_64 DModule_x86reg_64_x86reg_64_MIN = DModule_x86reg_64_RAX;
const DModule_x86reg_64 DModule_x86reg_64_x86reg_64_MAX = DModule_x86reg_64_LDT;
const int DModule_x86reg_64_x86reg_64_ARRAYSIZE = DModule_x86reg_64_x86reg_64_MAX + 1;

const ::google::protobuf::EnumDescriptor* DModule_x86reg_64_descriptor();
inline const ::std::string& DModule_x86reg_64_Name(DModule_x86reg_64 value) {
  return ::google::protobuf::internal::NameOfEnum(
    DModule_x86reg_64_descriptor(), value);
}
inline bool DModule_x86reg_64_Parse(
    const ::std::string& name, DModule_x86reg_64* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DModule_x86reg_64>(
    DModule_x86reg_64_descriptor(), name, value);
}
enum DModule_armreg {
  DModule_armreg_AR1 = 0,
  DModule_armreg_AR2 = 1,
  DModule_armreg_AR3 = 2,
  DModule_armreg_AR4 = 3,
  DModule_armreg_AR5 = 4,
  DModule_armreg_AR6 = 5,
  DModule_armreg_AR7 = 6,
  DModule_armreg_AR8 = 7,
  DModule_armreg_AR9 = 8,
  DModule_armreg_AR10 = 9,
  DModule_armreg_AR11 = 10,
  DModule_armreg_AR12 = 11,
  DModule_armreg_AR13 = 12,
  DModule_armreg_AR14 = 13,
  DModule_armreg_AR15 = 14
};
bool DModule_armreg_IsValid(int value);
const DModule_armreg DModule_armreg_armreg_MIN = DModule_armreg_AR1;
const DModule_armreg DModule_armreg_armreg_MAX = DModule_armreg_AR15;
const int DModule_armreg_armreg_ARRAYSIZE = DModule_armreg_armreg_MAX + 1;

const ::google::protobuf::EnumDescriptor* DModule_armreg_descriptor();
inline const ::std::string& DModule_armreg_Name(DModule_armreg value) {
  return ::google::protobuf::internal::NameOfEnum(
    DModule_armreg_descriptor(), value);
}
inline bool DModule_armreg_Parse(
    const ::std::string& name, DModule_armreg* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DModule_armreg>(
    DModule_armreg_descriptor(), name, value);
}
// ===================================================================

class DModule_TArch : public ::google::protobuf::Message {
 public:
  DModule_TArch();
  virtual ~DModule_TArch();

  DModule_TArch(const DModule_TArch& from);

  inline DModule_TArch& operator=(const DModule_TArch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DModule_TArch& default_instance();

  void Swap(DModule_TArch* other);

  // implements Message ----------------------------------------------

  DModule_TArch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DModule_TArch& from);
  void MergeFrom(const DModule_TArch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DModule.TArchMajor major = 1;
  inline bool has_major() const;
  inline void clear_major();
  static const int kMajorFieldNumber = 1;
  inline ::DModule_TArchMajor major() const;
  inline void set_major(::DModule_TArchMajor value);

  // required .DModule.TArchMinor minor = 2;
  inline bool has_minor() const;
  inline void clear_minor();
  static const int kMinorFieldNumber = 2;
  inline ::DModule_TArchMinor minor() const;
  inline void set_minor(::DModule_TArchMinor value);

  // @@protoc_insertion_point(class_scope:DModule.TArch)
 private:
  inline void set_has_major();
  inline void clear_has_major();
  inline void set_has_minor();
  inline void clear_has_minor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int major_;
  int minor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_IR_2eproto();
  friend void protobuf_AssignDesc_IR_2eproto();
  friend void protobuf_ShutdownFile_IR_2eproto();

  void InitAsDefaultInstance();
  static DModule_TArch* default_instance_;
};
// -------------------------------------------------------------------

class DModule_ConstantValue : public ::google::protobuf::Message {
 public:
  DModule_ConstantValue();
  virtual ~DModule_ConstantValue();

  DModule_ConstantValue(const DModule_ConstantValue& from);

  inline DModule_ConstantValue& operator=(const DModule_ConstantValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DModule_ConstantValue& default_instance();

  void Swap(DModule_ConstantValue* other);

  // implements Message ----------------------------------------------

  DModule_ConstantValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DModule_ConstantValue& from);
  void MergeFrom(const DModule_ConstantValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DModule.ValTy ty = 1;
  inline bool has_ty() const;
  inline void clear_ty();
  static const int kTyFieldNumber = 1;
  inline ::DModule_ValTy ty() const;
  inline void set_ty(::DModule_ValTy value);

  // required bool isKnown = 2;
  inline bool has_isknown() const;
  inline void clear_isknown();
  static const int kIsKnownFieldNumber = 2;
  inline bool isknown() const;
  inline void set_isknown(bool value);

  // required int32 width = 3;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 3;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // optional int64 val = 4;
  inline bool has_val() const;
  inline void clear_val();
  static const int kValFieldNumber = 4;
  inline ::google::protobuf::int64 val() const;
  inline void set_val(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:DModule.ConstantValue)
 private:
  inline void set_has_ty();
  inline void clear_has_ty();
  inline void set_has_isknown();
  inline void clear_has_isknown();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_val();
  inline void clear_has_val();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ty_;
  bool isknown_;
  ::google::protobuf::int64 val_;
  ::google::protobuf::int32 width_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_IR_2eproto();
  friend void protobuf_AssignDesc_IR_2eproto();
  friend void protobuf_ShutdownFile_IR_2eproto();

  void InitAsDefaultInstance();
  static DModule_ConstantValue* default_instance_;
};
// -------------------------------------------------------------------

class DModule_TVar : public ::google::protobuf::Message {
 public:
  DModule_TVar();
  virtual ~DModule_TVar();

  DModule_TVar(const DModule_TVar& from);

  inline DModule_TVar& operator=(const DModule_TVar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DModule_TVar& default_instance();

  void Swap(DModule_TVar* other);

  // implements Message ----------------------------------------------

  DModule_TVar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DModule_TVar& from);
  void MergeFrom(const DModule_TVar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 varIdx = 1;
  inline bool has_varidx() const;
  inline void clear_varidx();
  static const int kVarIdxFieldNumber = 1;
  inline ::google::protobuf::int32 varidx() const;
  inline void set_varidx(::google::protobuf::int32 value);

  // required int32 width = 2;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 2;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // required .DModule.ValTy ty = 3;
  inline bool has_ty() const;
  inline void clear_ty();
  static const int kTyFieldNumber = 3;
  inline ::DModule_ValTy ty() const;
  inline void set_ty(::DModule_ValTy value);

  // @@protoc_insertion_point(class_scope:DModule.TVar)
 private:
  inline void set_has_varidx();
  inline void clear_has_varidx();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_ty();
  inline void clear_has_ty();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 varidx_;
  ::google::protobuf::int32 width_;
  int ty_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_IR_2eproto();
  friend void protobuf_AssignDesc_IR_2eproto();
  friend void protobuf_ShutdownFile_IR_2eproto();

  void InitAsDefaultInstance();
  static DModule_TVar* default_instance_;
};
// -------------------------------------------------------------------

class DModule_RegArray : public ::google::protobuf::Message {
 public:
  DModule_RegArray();
  virtual ~DModule_RegArray();

  DModule_RegArray(const DModule_RegArray& from);

  inline DModule_RegArray& operator=(const DModule_RegArray& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DModule_RegArray& default_instance();

  void Swap(DModule_RegArray* other);

  // implements Message ----------------------------------------------

  DModule_RegArray* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DModule_RegArray& from);
  void MergeFrom(const DModule_RegArray& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline ::google::protobuf::int32 base() const;
  inline void set_base(::google::protobuf::int32 value);

  // required .DModule.ValTy ty = 2;
  inline bool has_ty() const;
  inline void clear_ty();
  static const int kTyFieldNumber = 2;
  inline ::DModule_ValTy ty() const;
  inline void set_ty(::DModule_ValTy value);

  // required int32 numElems = 3;
  inline bool has_numelems() const;
  inline void clear_numelems();
  static const int kNumElemsFieldNumber = 3;
  inline ::google::protobuf::int32 numelems() const;
  inline void set_numelems(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DModule.RegArray)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_ty();
  inline void clear_has_ty();
  inline void set_has_numelems();
  inline void clear_has_numelems();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 base_;
  int ty_;
  ::google::protobuf::int32 numelems_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_IR_2eproto();
  friend void protobuf_AssignDesc_IR_2eproto();
  friend void protobuf_ShutdownFile_IR_2eproto();

  void InitAsDefaultInstance();
  static DModule_RegArray* default_instance_;
};
// -------------------------------------------------------------------

class DModule_Expression : public ::google::protobuf::Message {
 public:
  DModule_Expression();
  virtual ~DModule_Expression();

  DModule_Expression(const DModule_Expression& from);

  inline DModule_Expression& operator=(const DModule_Expression& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DModule_Expression& default_instance();

  void Swap(DModule_Expression* other);

  // implements Message ----------------------------------------------

  DModule_Expression* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DModule_Expression& from);
  void MergeFrom(const DModule_Expression& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DModule.ExType ty = 1;
  inline bool has_ty() const;
  inline void clear_ty();
  static const int kTyFieldNumber = 1;
  inline ::DModule_ExType ty() const;
  inline void set_ty(::DModule_ExType value);

  // optional .DModule.Ops Op_opcode = 2;
  inline bool has_op_opcode() const;
  inline void clear_op_opcode();
  static const int kOpOpcodeFieldNumber = 2;
  inline ::DModule_Ops op_opcode() const;
  inline void set_op_opcode(::DModule_Ops value);

  // repeated .DModule.Expression Op_arguments = 3;
  inline int op_arguments_size() const;
  inline void clear_op_arguments();
  static const int kOpArgumentsFieldNumber = 3;
  inline const ::DModule_Expression& op_arguments(int index) const;
  inline ::DModule_Expression* mutable_op_arguments(int index);
  inline ::DModule_Expression* add_op_arguments();
  inline const ::google::protobuf::RepeatedPtrField< ::DModule_Expression >&
      op_arguments() const;
  inline ::google::protobuf::RepeatedPtrField< ::DModule_Expression >*
      mutable_op_arguments();

  // optional .DModule.TVar RdTmp_tval = 4;
  inline bool has_rdtmp_tval() const;
  inline void clear_rdtmp_tval();
  static const int kRdTmpTvalFieldNumber = 4;
  inline const ::DModule_TVar& rdtmp_tval() const;
  inline ::DModule_TVar* mutable_rdtmp_tval();
  inline ::DModule_TVar* release_rdtmp_tval();
  inline void set_allocated_rdtmp_tval(::DModule_TVar* rdtmp_tval);

  // optional .DModule.ValTy Load_loadTy = 5;
  inline bool has_load_loadty() const;
  inline void clear_load_loadty();
  static const int kLoadLoadTyFieldNumber = 5;
  inline ::DModule_ValTy load_loadty() const;
  inline void set_load_loadty(::DModule_ValTy value);

  // optional .DModule.Expression Load_addr = 6;
  inline bool has_load_addr() const;
  inline void clear_load_addr();
  static const int kLoadAddrFieldNumber = 6;
  inline const ::DModule_Expression& load_addr() const;
  inline ::DModule_Expression* mutable_load_addr();
  inline ::DModule_Expression* release_load_addr();
  inline void set_allocated_load_addr(::DModule_Expression* load_addr);

  // optional .DModule.Register Get_register = 7;
  inline bool has_get_register() const;
  inline void clear_get_register();
  static const int kGetRegisterFieldNumber = 7;
  inline const ::DModule_Register& get_register() const;
  inline ::DModule_Register* mutable_get_register();
  inline ::DModule_Register* release_get_register();
  inline void set_allocated_get_register(::DModule_Register* get_register);

  // optional .DModule.ConstantValue Const_cval = 8;
  inline bool has_const_cval() const;
  inline void clear_const_cval();
  static const int kConstCvalFieldNumber = 8;
  inline const ::DModule_ConstantValue& const_cval() const;
  inline ::DModule_ConstantValue* mutable_const_cval();
  inline ::DModule_ConstantValue* release_const_cval();
  inline void set_allocated_const_cval(::DModule_ConstantValue* const_cval);

  // optional .DModule.Expression Mux0X_condition = 9;
  inline bool has_mux0x_condition() const;
  inline void clear_mux0x_condition();
  static const int kMux0XConditionFieldNumber = 9;
  inline const ::DModule_Expression& mux0x_condition() const;
  inline ::DModule_Expression* mutable_mux0x_condition();
  inline ::DModule_Expression* release_mux0x_condition();
  inline void set_allocated_mux0x_condition(::DModule_Expression* mux0x_condition);

  // optional .DModule.Expression Mux0X_iftrue = 10;
  inline bool has_mux0x_iftrue() const;
  inline void clear_mux0x_iftrue();
  static const int kMux0XIftrueFieldNumber = 10;
  inline const ::DModule_Expression& mux0x_iftrue() const;
  inline ::DModule_Expression* mutable_mux0x_iftrue();
  inline ::DModule_Expression* release_mux0x_iftrue();
  inline void set_allocated_mux0x_iftrue(::DModule_Expression* mux0x_iftrue);

  // optional .DModule.Expression Mux0X_iffalse = 11;
  inline bool has_mux0x_iffalse() const;
  inline void clear_mux0x_iffalse();
  static const int kMux0XIffalseFieldNumber = 11;
  inline const ::DModule_Expression& mux0x_iffalse() const;
  inline ::DModule_Expression* mutable_mux0x_iffalse();
  inline ::DModule_Expression* release_mux0x_iffalse();
  inline void set_allocated_mux0x_iffalse(::DModule_Expression* mux0x_iffalse);

  // optional .DModule.RegArray Get_regarray = 12;
  inline bool has_get_regarray() const;
  inline void clear_get_regarray();
  static const int kGetRegarrayFieldNumber = 12;
  inline const ::DModule_RegArray& get_regarray() const;
  inline ::DModule_RegArray* mutable_get_regarray();
  inline ::DModule_RegArray* release_get_regarray();
  inline void set_allocated_get_regarray(::DModule_RegArray* get_regarray);

  // optional string CCall_targetFunc = 13;
  inline bool has_ccall_targetfunc() const;
  inline void clear_ccall_targetfunc();
  static const int kCCallTargetFuncFieldNumber = 13;
  inline const ::std::string& ccall_targetfunc() const;
  inline void set_ccall_targetfunc(const ::std::string& value);
  inline void set_ccall_targetfunc(const char* value);
  inline void set_ccall_targetfunc(const char* value, size_t size);
  inline ::std::string* mutable_ccall_targetfunc();
  inline ::std::string* release_ccall_targetfunc();
  inline void set_allocated_ccall_targetfunc(::std::string* ccall_targetfunc);

  // repeated .DModule.Expression CCall_args = 14;
  inline int ccall_args_size() const;
  inline void clear_ccall_args();
  static const int kCCallArgsFieldNumber = 14;
  inline const ::DModule_Expression& ccall_args(int index) const;
  inline ::DModule_Expression* mutable_ccall_args(int index);
  inline ::DModule_Expression* add_ccall_args();
  inline const ::google::protobuf::RepeatedPtrField< ::DModule_Expression >&
      ccall_args() const;
  inline ::google::protobuf::RepeatedPtrField< ::DModule_Expression >*
      mutable_ccall_args();

  // optional .DModule.Expression Get_varpart = 15;
  inline bool has_get_varpart() const;
  inline void clear_get_varpart();
  static const int kGetVarpartFieldNumber = 15;
  inline const ::DModule_Expression& get_varpart() const;
  inline ::DModule_Expression* mutable_get_varpart();
  inline ::DModule_Expression* release_get_varpart();
  inline void set_allocated_get_varpart(::DModule_Expression* get_varpart);

  // optional int32 Get_bias = 16;
  inline bool has_get_bias() const;
  inline void clear_get_bias();
  static const int kGetBiasFieldNumber = 16;
  inline ::google::protobuf::int32 get_bias() const;
  inline void set_get_bias(::google::protobuf::int32 value);

  // optional .DModule.TArch Get_arch = 17;
  inline bool has_get_arch() const;
  inline void clear_get_arch();
  static const int kGetArchFieldNumber = 17;
  inline const ::DModule_TArch& get_arch() const;
  inline ::DModule_TArch* mutable_get_arch();
  inline ::DModule_TArch* release_get_arch();
  inline void set_allocated_get_arch(::DModule_TArch* get_arch);

  // optional int32 Get_offset = 18;
  inline bool has_get_offset() const;
  inline void clear_get_offset();
  static const int kGetOffsetFieldNumber = 18;
  inline ::google::protobuf::int32 get_offset() const;
  inline void set_get_offset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DModule.Expression)
 private:
  inline void set_has_ty();
  inline void clear_has_ty();
  inline void set_has_op_opcode();
  inline void clear_has_op_opcode();
  inline void set_has_rdtmp_tval();
  inline void clear_has_rdtmp_tval();
  inline void set_has_load_loadty();
  inline void clear_has_load_loadty();
  inline void set_has_load_addr();
  inline void clear_has_load_addr();
  inline void set_has_get_register();
  inline void clear_has_get_register();
  inline void set_has_const_cval();
  inline void clear_has_const_cval();
  inline void set_has_mux0x_condition();
  inline void clear_has_mux0x_condition();
  inline void set_has_mux0x_iftrue();
  inline void clear_has_mux0x_iftrue();
  inline void set_has_mux0x_iffalse();
  inline void clear_has_mux0x_iffalse();
  inline void set_has_get_regarray();
  inline void clear_has_get_regarray();
  inline void set_has_ccall_targetfunc();
  inline void clear_has_ccall_targetfunc();
  inline void set_has_get_varpart();
  inline void clear_has_get_varpart();
  inline void set_has_get_bias();
  inline void clear_has_get_bias();
  inline void set_has_get_arch();
  inline void clear_has_get_arch();
  inline void set_has_get_offset();
  inline void clear_has_get_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ty_;
  int op_opcode_;
  ::google::protobuf::RepeatedPtrField< ::DModule_Expression > op_arguments_;
  ::DModule_TVar* rdtmp_tval_;
  ::DModule_Expression* load_addr_;
  ::DModule_Register* get_register_;
  ::DModule_ConstantValue* const_cval_;
  ::DModule_Expression* mux0x_condition_;
  ::DModule_Expression* mux0x_iftrue_;
  int load_loadty_;
  ::google::protobuf::int32 get_bias_;
  ::DModule_Expression* mux0x_iffalse_;
  ::DModule_RegArray* get_regarray_;
  ::std::string* ccall_targetfunc_;
  ::google::protobuf::RepeatedPtrField< ::DModule_Expression > ccall_args_;
  ::DModule_Expression* get_varpart_;
  ::DModule_TArch* get_arch_;
  ::google::protobuf::int32 get_offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_IR_2eproto();
  friend void protobuf_AssignDesc_IR_2eproto();
  friend void protobuf_ShutdownFile_IR_2eproto();

  void InitAsDefaultInstance();
  static DModule_Expression* default_instance_;
};
// -------------------------------------------------------------------

class DModule_Register : public ::google::protobuf::Message {
 public:
  DModule_Register();
  virtual ~DModule_Register();

  DModule_Register(const DModule_Register& from);

  inline DModule_Register& operator=(const DModule_Register& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DModule_Register& default_instance();

  void Swap(DModule_Register* other);

  // implements Message ----------------------------------------------

  DModule_Register* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DModule_Register& from);
  void MergeFrom(const DModule_Register& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DModule.TArch arch = 1;
  inline bool has_arch() const;
  inline void clear_arch();
  static const int kArchFieldNumber = 1;
  inline const ::DModule_TArch& arch() const;
  inline ::DModule_TArch* mutable_arch();
  inline ::DModule_TArch* release_arch();
  inline void set_allocated_arch(::DModule_TArch* arch);

  // optional .DModule.RegisterClass regClass = 2;
  inline bool has_regclass() const;
  inline void clear_regclass();
  static const int kRegClassFieldNumber = 2;
  inline ::DModule_RegisterClass regclass() const;
  inline void set_regclass(::DModule_RegisterClass value);

  // optional int32 width = 3;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 3;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // optional .DModule.x86reg_8 Reg8 = 4;
  inline bool has_reg8() const;
  inline void clear_reg8();
  static const int kReg8FieldNumber = 4;
  inline ::DModule_x86reg_8 reg8() const;
  inline void set_reg8(::DModule_x86reg_8 value);

  // optional .DModule.x86reg_16 Reg16 = 5;
  inline bool has_reg16() const;
  inline void clear_reg16();
  static const int kReg16FieldNumber = 5;
  inline ::DModule_x86reg_16 reg16() const;
  inline void set_reg16(::DModule_x86reg_16 value);

  // optional .DModule.x86reg_32 Reg32 = 6;
  inline bool has_reg32() const;
  inline void clear_reg32();
  static const int kReg32FieldNumber = 6;
  inline ::DModule_x86reg_32 reg32() const;
  inline void set_reg32(::DModule_x86reg_32 value);

  // optional .DModule.x86reg_64 Reg64 = 7;
  inline bool has_reg64() const;
  inline void clear_reg64();
  static const int kReg64FieldNumber = 7;
  inline ::DModule_x86reg_64 reg64() const;
  inline void set_reg64(::DModule_x86reg_64 value);

  // optional .DModule.armreg RegArm = 8;
  inline bool has_regarm() const;
  inline void clear_regarm();
  static const int kRegArmFieldNumber = 8;
  inline ::DModule_armreg regarm() const;
  inline void set_regarm(::DModule_armreg value);

  // @@protoc_insertion_point(class_scope:DModule.Register)
 private:
  inline void set_has_arch();
  inline void clear_has_arch();
  inline void set_has_regclass();
  inline void clear_has_regclass();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_reg8();
  inline void clear_has_reg8();
  inline void set_has_reg16();
  inline void clear_has_reg16();
  inline void set_has_reg32();
  inline void clear_has_reg32();
  inline void set_has_reg64();
  inline void clear_has_reg64();
  inline void set_has_regarm();
  inline void clear_has_regarm();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::DModule_TArch* arch_;
  int regclass_;
  ::google::protobuf::int32 width_;
  int reg8_;
  int reg16_;
  int reg32_;
  int reg64_;
  int regarm_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_IR_2eproto();
  friend void protobuf_AssignDesc_IR_2eproto();
  friend void protobuf_ShutdownFile_IR_2eproto();

  void InitAsDefaultInstance();
  static DModule_Register* default_instance_;
};
// -------------------------------------------------------------------

class DModule_Statement : public ::google::protobuf::Message {
 public:
  DModule_Statement();
  virtual ~DModule_Statement();

  DModule_Statement(const DModule_Statement& from);

  inline DModule_Statement& operator=(const DModule_Statement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DModule_Statement& default_instance();

  void Swap(DModule_Statement* other);

  // implements Message ----------------------------------------------

  DModule_Statement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DModule_Statement& from);
  void MergeFrom(const DModule_Statement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DModule.StType ty = 1;
  inline bool has_ty() const;
  inline void clear_ty();
  static const int kTyFieldNumber = 1;
  inline ::DModule_StType ty() const;
  inline void set_ty(::DModule_StType value);

  // optional .DModule.Expression WrTmp_RHS = 2;
  inline bool has_wrtmp_rhs() const;
  inline void clear_wrtmp_rhs();
  static const int kWrTmpRHSFieldNumber = 2;
  inline const ::DModule_Expression& wrtmp_rhs() const;
  inline ::DModule_Expression* mutable_wrtmp_rhs();
  inline ::DModule_Expression* release_wrtmp_rhs();
  inline void set_allocated_wrtmp_rhs(::DModule_Expression* wrtmp_rhs);

  // optional .DModule.TVar WrTmp_tmpWritten = 3;
  inline bool has_wrtmp_tmpwritten() const;
  inline void clear_wrtmp_tmpwritten();
  static const int kWrTmpTmpWrittenFieldNumber = 3;
  inline const ::DModule_TVar& wrtmp_tmpwritten() const;
  inline ::DModule_TVar* mutable_wrtmp_tmpwritten();
  inline ::DModule_TVar* release_wrtmp_tmpwritten();
  inline void set_allocated_wrtmp_tmpwritten(::DModule_TVar* wrtmp_tmpwritten);

  // optional .DModule.Expression Put_data = 4;
  inline bool has_put_data() const;
  inline void clear_put_data();
  static const int kPutDataFieldNumber = 4;
  inline const ::DModule_Expression& put_data() const;
  inline ::DModule_Expression* mutable_put_data();
  inline ::DModule_Expression* release_put_data();
  inline void set_allocated_put_data(::DModule_Expression* put_data);

  // optional .DModule.Register Put_register = 5;
  inline bool has_put_register() const;
  inline void clear_put_register();
  static const int kPutRegisterFieldNumber = 5;
  inline const ::DModule_Register& put_register() const;
  inline ::DModule_Register* mutable_put_register();
  inline ::DModule_Register* release_put_register();
  inline void set_allocated_put_register(::DModule_Register* put_register);

  // optional .DModule.Expression Store_data = 6;
  inline bool has_store_data() const;
  inline void clear_store_data();
  static const int kStoreDataFieldNumber = 6;
  inline const ::DModule_Expression& store_data() const;
  inline ::DModule_Expression* mutable_store_data();
  inline ::DModule_Expression* release_store_data();
  inline void set_allocated_store_data(::DModule_Expression* store_data);

  // optional .DModule.Expression Store_addr = 7;
  inline bool has_store_addr() const;
  inline void clear_store_addr();
  static const int kStoreAddrFieldNumber = 7;
  inline const ::DModule_Expression& store_addr() const;
  inline ::DModule_Expression* mutable_store_addr();
  inline ::DModule_Expression* release_store_addr();
  inline void set_allocated_store_addr(::DModule_Expression* store_addr);

  // optional .DModule.ExitType Exit_blockexit = 8;
  inline bool has_exit_blockexit() const;
  inline void clear_exit_blockexit();
  static const int kExitBlockexitFieldNumber = 8;
  inline ::DModule_ExitType exit_blockexit() const;
  inline void set_exit_blockexit(::DModule_ExitType value);

  // optional .DModule.Expression Exit_guardExp = 9;
  inline bool has_exit_guardexp() const;
  inline void clear_exit_guardexp();
  static const int kExitGuardExpFieldNumber = 9;
  inline const ::DModule_Expression& exit_guardexp() const;
  inline ::DModule_Expression* mutable_exit_guardexp();
  inline ::DModule_Expression* release_exit_guardexp();
  inline void set_allocated_exit_guardexp(::DModule_Expression* exit_guardexp);

  // optional .DModule.Expression Exit_jmpTarget = 10;
  inline bool has_exit_jmptarget() const;
  inline void clear_exit_jmptarget();
  static const int kExitJmpTargetFieldNumber = 10;
  inline const ::DModule_Expression& exit_jmptarget() const;
  inline ::DModule_Expression* mutable_exit_jmptarget();
  inline ::DModule_Expression* release_exit_jmptarget();
  inline void set_allocated_exit_jmptarget(::DModule_Expression* exit_jmptarget);

  // optional .DModule.Expression LLSC_addr = 11;
  inline bool has_llsc_addr() const;
  inline void clear_llsc_addr();
  static const int kLLSCAddrFieldNumber = 11;
  inline const ::DModule_Expression& llsc_addr() const;
  inline ::DModule_Expression* mutable_llsc_addr();
  inline ::DModule_Expression* release_llsc_addr();
  inline void set_allocated_llsc_addr(::DModule_Expression* llsc_addr);

  // optional .DModule.Expression LLSC_storedata = 12;
  inline bool has_llsc_storedata() const;
  inline void clear_llsc_storedata();
  static const int kLLSCStoredataFieldNumber = 12;
  inline const ::DModule_Expression& llsc_storedata() const;
  inline ::DModule_Expression* mutable_llsc_storedata();
  inline ::DModule_Expression* release_llsc_storedata();
  inline void set_allocated_llsc_storedata(::DModule_Expression* llsc_storedata);

  // optional .DModule.TVar LLSC_result = 13;
  inline bool has_llsc_result() const;
  inline void clear_llsc_result();
  static const int kLLSCResultFieldNumber = 13;
  inline const ::DModule_TVar& llsc_result() const;
  inline ::DModule_TVar* mutable_llsc_result();
  inline ::DModule_TVar* release_llsc_result();
  inline void set_allocated_llsc_result(::DModule_TVar* llsc_result);

  // optional .DModule.Expression Dirty_addr = 14;
  inline bool has_dirty_addr() const;
  inline void clear_dirty_addr();
  static const int kDirtyAddrFieldNumber = 14;
  inline const ::DModule_Expression& dirty_addr() const;
  inline ::DModule_Expression* mutable_dirty_addr();
  inline ::DModule_Expression* release_dirty_addr();
  inline void set_allocated_dirty_addr(::DModule_Expression* dirty_addr);

  // optional .DModule.Expression Dirty_guard = 15;
  inline bool has_dirty_guard() const;
  inline void clear_dirty_guard();
  static const int kDirtyGuardFieldNumber = 15;
  inline const ::DModule_Expression& dirty_guard() const;
  inline ::DModule_Expression* mutable_dirty_guard();
  inline ::DModule_Expression* release_dirty_guard();
  inline void set_allocated_dirty_guard(::DModule_Expression* dirty_guard);

  // repeated .DModule.Expression Dirty_args = 16;
  inline int dirty_args_size() const;
  inline void clear_dirty_args();
  static const int kDirtyArgsFieldNumber = 16;
  inline const ::DModule_Expression& dirty_args(int index) const;
  inline ::DModule_Expression* mutable_dirty_args(int index);
  inline ::DModule_Expression* add_dirty_args();
  inline const ::google::protobuf::RepeatedPtrField< ::DModule_Expression >&
      dirty_args() const;
  inline ::google::protobuf::RepeatedPtrField< ::DModule_Expression >*
      mutable_dirty_args();

  // optional string Dirty_calleename = 17;
  inline bool has_dirty_calleename() const;
  inline void clear_dirty_calleename();
  static const int kDirtyCalleenameFieldNumber = 17;
  inline const ::std::string& dirty_calleename() const;
  inline void set_dirty_calleename(const ::std::string& value);
  inline void set_dirty_calleename(const char* value);
  inline void set_dirty_calleename(const char* value, size_t size);
  inline ::std::string* mutable_dirty_calleename();
  inline ::std::string* release_dirty_calleename();
  inline void set_allocated_dirty_calleename(::std::string* dirty_calleename);

  // optional .DModule.TVar Dirty_tmp = 18;
  inline bool has_dirty_tmp() const;
  inline void clear_dirty_tmp();
  static const int kDirtyTmpFieldNumber = 18;
  inline const ::DModule_TVar& dirty_tmp() const;
  inline ::DModule_TVar* mutable_dirty_tmp();
  inline ::DModule_TVar* release_dirty_tmp();
  inline void set_allocated_dirty_tmp(::DModule_TVar* dirty_tmp);

  // optional .DModule.Expression CAS_storeAddr = 19;
  inline bool has_cas_storeaddr() const;
  inline void clear_cas_storeaddr();
  static const int kCASStoreAddrFieldNumber = 19;
  inline const ::DModule_Expression& cas_storeaddr() const;
  inline ::DModule_Expression* mutable_cas_storeaddr();
  inline ::DModule_Expression* release_cas_storeaddr();
  inline void set_allocated_cas_storeaddr(::DModule_Expression* cas_storeaddr);

  // optional .DModule.Expression CAS_datahi = 20;
  inline bool has_cas_datahi() const;
  inline void clear_cas_datahi();
  static const int kCASDatahiFieldNumber = 20;
  inline const ::DModule_Expression& cas_datahi() const;
  inline ::DModule_Expression* mutable_cas_datahi();
  inline ::DModule_Expression* release_cas_datahi();
  inline void set_allocated_cas_datahi(::DModule_Expression* cas_datahi);

  // optional .DModule.Expression CAS_datalo = 21;
  inline bool has_cas_datalo() const;
  inline void clear_cas_datalo();
  static const int kCASDataloFieldNumber = 21;
  inline const ::DModule_Expression& cas_datalo() const;
  inline ::DModule_Expression* mutable_cas_datalo();
  inline ::DModule_Expression* release_cas_datalo();
  inline void set_allocated_cas_datalo(::DModule_Expression* cas_datalo);

  // optional .DModule.Expression CAS_expectedhi = 22;
  inline bool has_cas_expectedhi() const;
  inline void clear_cas_expectedhi();
  static const int kCASExpectedhiFieldNumber = 22;
  inline const ::DModule_Expression& cas_expectedhi() const;
  inline ::DModule_Expression* mutable_cas_expectedhi();
  inline ::DModule_Expression* release_cas_expectedhi();
  inline void set_allocated_cas_expectedhi(::DModule_Expression* cas_expectedhi);

  // optional .DModule.Expression CAS_expectedlo = 23;
  inline bool has_cas_expectedlo() const;
  inline void clear_cas_expectedlo();
  static const int kCASExpectedloFieldNumber = 23;
  inline const ::DModule_Expression& cas_expectedlo() const;
  inline ::DModule_Expression* mutable_cas_expectedlo();
  inline ::DModule_Expression* release_cas_expectedlo();
  inline void set_allocated_cas_expectedlo(::DModule_Expression* cas_expectedlo);

  // optional .DModule.TVar CAS_oldhi = 24;
  inline bool has_cas_oldhi() const;
  inline void clear_cas_oldhi();
  static const int kCASOldhiFieldNumber = 24;
  inline const ::DModule_TVar& cas_oldhi() const;
  inline ::DModule_TVar* mutable_cas_oldhi();
  inline ::DModule_TVar* release_cas_oldhi();
  inline void set_allocated_cas_oldhi(::DModule_TVar* cas_oldhi);

  // optional .DModule.TVar CAS_oldlo = 25;
  inline bool has_cas_oldlo() const;
  inline void clear_cas_oldlo();
  static const int kCASOldloFieldNumber = 25;
  inline const ::DModule_TVar& cas_oldlo() const;
  inline ::DModule_TVar* mutable_cas_oldlo();
  inline ::DModule_TVar* release_cas_oldlo();
  inline void set_allocated_cas_oldlo(::DModule_TVar* cas_oldlo);

  // optional .DModule.MemoryEnd CAS_end = 26;
  inline bool has_cas_end() const;
  inline void clear_cas_end();
  static const int kCASEndFieldNumber = 26;
  inline ::DModule_MemoryEnd cas_end() const;
  inline void set_cas_end(::DModule_MemoryEnd value);

  // optional .DModule.MemoryEnd LLSC_end = 27;
  inline bool has_llsc_end() const;
  inline void clear_llsc_end();
  static const int kLLSCEndFieldNumber = 27;
  inline ::DModule_MemoryEnd llsc_end() const;
  inline void set_llsc_end(::DModule_MemoryEnd value);

  // optional .DModule.RegArray Put_regarray = 28;
  inline bool has_put_regarray() const;
  inline void clear_put_regarray();
  static const int kPutRegarrayFieldNumber = 28;
  inline const ::DModule_RegArray& put_regarray() const;
  inline ::DModule_RegArray* mutable_put_regarray();
  inline ::DModule_RegArray* release_put_regarray();
  inline void set_allocated_put_regarray(::DModule_RegArray* put_regarray);

  // optional int32 Put_bias = 29;
  inline bool has_put_bias() const;
  inline void clear_put_bias();
  static const int kPutBiasFieldNumber = 29;
  inline ::google::protobuf::int32 put_bias() const;
  inline void set_put_bias(::google::protobuf::int32 value);

  // optional .DModule.Expression Put_varpart = 30;
  inline bool has_put_varpart() const;
  inline void clear_put_varpart();
  static const int kPutVarpartFieldNumber = 30;
  inline const ::DModule_Expression& put_varpart() const;
  inline ::DModule_Expression* mutable_put_varpart();
  inline ::DModule_Expression* release_put_varpart();
  inline void set_allocated_put_varpart(::DModule_Expression* put_varpart);

  // @@protoc_insertion_point(class_scope:DModule.Statement)
 private:
  inline void set_has_ty();
  inline void clear_has_ty();
  inline void set_has_wrtmp_rhs();
  inline void clear_has_wrtmp_rhs();
  inline void set_has_wrtmp_tmpwritten();
  inline void clear_has_wrtmp_tmpwritten();
  inline void set_has_put_data();
  inline void clear_has_put_data();
  inline void set_has_put_register();
  inline void clear_has_put_register();
  inline void set_has_store_data();
  inline void clear_has_store_data();
  inline void set_has_store_addr();
  inline void clear_has_store_addr();
  inline void set_has_exit_blockexit();
  inline void clear_has_exit_blockexit();
  inline void set_has_exit_guardexp();
  inline void clear_has_exit_guardexp();
  inline void set_has_exit_jmptarget();
  inline void clear_has_exit_jmptarget();
  inline void set_has_llsc_addr();
  inline void clear_has_llsc_addr();
  inline void set_has_llsc_storedata();
  inline void clear_has_llsc_storedata();
  inline void set_has_llsc_result();
  inline void clear_has_llsc_result();
  inline void set_has_dirty_addr();
  inline void clear_has_dirty_addr();
  inline void set_has_dirty_guard();
  inline void clear_has_dirty_guard();
  inline void set_has_dirty_calleename();
  inline void clear_has_dirty_calleename();
  inline void set_has_dirty_tmp();
  inline void clear_has_dirty_tmp();
  inline void set_has_cas_storeaddr();
  inline void clear_has_cas_storeaddr();
  inline void set_has_cas_datahi();
  inline void clear_has_cas_datahi();
  inline void set_has_cas_datalo();
  inline void clear_has_cas_datalo();
  inline void set_has_cas_expectedhi();
  inline void clear_has_cas_expectedhi();
  inline void set_has_cas_expectedlo();
  inline void clear_has_cas_expectedlo();
  inline void set_has_cas_oldhi();
  inline void clear_has_cas_oldhi();
  inline void set_has_cas_oldlo();
  inline void clear_has_cas_oldlo();
  inline void set_has_cas_end();
  inline void clear_has_cas_end();
  inline void set_has_llsc_end();
  inline void clear_has_llsc_end();
  inline void set_has_put_regarray();
  inline void clear_has_put_regarray();
  inline void set_has_put_bias();
  inline void clear_has_put_bias();
  inline void set_has_put_varpart();
  inline void clear_has_put_varpart();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::DModule_Expression* wrtmp_rhs_;
  ::DModule_TVar* wrtmp_tmpwritten_;
  ::DModule_Expression* put_data_;
  int ty_;
  int exit_blockexit_;
  ::DModule_Register* put_register_;
  ::DModule_Expression* store_data_;
  ::DModule_Expression* store_addr_;
  ::DModule_Expression* exit_guardexp_;
  ::DModule_Expression* exit_jmptarget_;
  ::DModule_Expression* llsc_addr_;
  ::DModule_Expression* llsc_storedata_;
  ::DModule_TVar* llsc_result_;
  ::DModule_Expression* dirty_addr_;
  ::DModule_Expression* dirty_guard_;
  ::google::protobuf::RepeatedPtrField< ::DModule_Expression > dirty_args_;
  ::std::string* dirty_calleename_;
  ::DModule_TVar* dirty_tmp_;
  ::DModule_Expression* cas_storeaddr_;
  ::DModule_Expression* cas_datahi_;
  ::DModule_Expression* cas_datalo_;
  ::DModule_Expression* cas_expectedhi_;
  ::DModule_Expression* cas_expectedlo_;
  ::DModule_TVar* cas_oldhi_;
  ::DModule_TVar* cas_oldlo_;
  int cas_end_;
  int llsc_end_;
  ::DModule_RegArray* put_regarray_;
  ::DModule_Expression* put_varpart_;
  ::google::protobuf::int32 put_bias_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(30 + 31) / 32];

  friend void  protobuf_AddDesc_IR_2eproto();
  friend void protobuf_AssignDesc_IR_2eproto();
  friend void protobuf_ShutdownFile_IR_2eproto();

  void InitAsDefaultInstance();
  static DModule_Statement* default_instance_;
};
// -------------------------------------------------------------------

class DModule_DBlock : public ::google::protobuf::Message {
 public:
  DModule_DBlock();
  virtual ~DModule_DBlock();

  DModule_DBlock(const DModule_DBlock& from);

  inline DModule_DBlock& operator=(const DModule_DBlock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DModule_DBlock& default_instance();

  void Swap(DModule_DBlock* other);

  // implements Message ----------------------------------------------

  DModule_DBlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DModule_DBlock& from);
  void MergeFrom(const DModule_DBlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 baseAddr = 1;
  inline bool has_baseaddr() const;
  inline void clear_baseaddr();
  static const int kBaseAddrFieldNumber = 1;
  inline ::google::protobuf::int64 baseaddr() const;
  inline void set_baseaddr(::google::protobuf::int64 value);

  // repeated .DModule.TVar temps = 2;
  inline int temps_size() const;
  inline void clear_temps();
  static const int kTempsFieldNumber = 2;
  inline const ::DModule_TVar& temps(int index) const;
  inline ::DModule_TVar* mutable_temps(int index);
  inline ::DModule_TVar* add_temps();
  inline const ::google::protobuf::RepeatedPtrField< ::DModule_TVar >&
      temps() const;
  inline ::google::protobuf::RepeatedPtrField< ::DModule_TVar >*
      mutable_temps();

  // required .DModule.TArch arch = 3;
  inline bool has_arch() const;
  inline void clear_arch();
  static const int kArchFieldNumber = 3;
  inline const ::DModule_TArch& arch() const;
  inline ::DModule_TArch* mutable_arch();
  inline ::DModule_TArch* release_arch();
  inline void set_allocated_arch(::DModule_TArch* arch);

  // required int32 len = 4;
  inline bool has_len() const;
  inline void clear_len();
  static const int kLenFieldNumber = 4;
  inline ::google::protobuf::int32 len() const;
  inline void set_len(::google::protobuf::int32 value);

  // repeated .DModule.Statement stmts = 5;
  inline int stmts_size() const;
  inline void clear_stmts();
  static const int kStmtsFieldNumber = 5;
  inline const ::DModule_Statement& stmts(int index) const;
  inline ::DModule_Statement* mutable_stmts(int index);
  inline ::DModule_Statement* add_stmts();
  inline const ::google::protobuf::RepeatedPtrField< ::DModule_Statement >&
      stmts() const;
  inline ::google::protobuf::RepeatedPtrField< ::DModule_Statement >*
      mutable_stmts();

  // required .DModule.Expression next = 6;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 6;
  inline const ::DModule_Expression& next() const;
  inline ::DModule_Expression* mutable_next();
  inline ::DModule_Expression* release_next();
  inline void set_allocated_next(::DModule_Expression* next);

  // required .DModule.ExitType blockExit = 7;
  inline bool has_blockexit() const;
  inline void clear_blockexit();
  static const int kBlockExitFieldNumber = 7;
  inline ::DModule_ExitType blockexit() const;
  inline void set_blockexit(::DModule_ExitType value);

  // @@protoc_insertion_point(class_scope:DModule.DBlock)
 private:
  inline void set_has_baseaddr();
  inline void clear_has_baseaddr();
  inline void set_has_arch();
  inline void clear_has_arch();
  inline void set_has_len();
  inline void clear_has_len();
  inline void set_has_next();
  inline void clear_has_next();
  inline void set_has_blockexit();
  inline void clear_has_blockexit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 baseaddr_;
  ::google::protobuf::RepeatedPtrField< ::DModule_TVar > temps_;
  ::DModule_TArch* arch_;
  ::google::protobuf::RepeatedPtrField< ::DModule_Statement > stmts_;
  ::google::protobuf::int32 len_;
  int blockexit_;
  ::DModule_Expression* next_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_IR_2eproto();
  friend void protobuf_AssignDesc_IR_2eproto();
  friend void protobuf_ShutdownFile_IR_2eproto();

  void InitAsDefaultInstance();
  static DModule_DBlock* default_instance_;
};
// -------------------------------------------------------------------

class DModule : public ::google::protobuf::Message {
 public:
  DModule();
  virtual ~DModule();

  DModule(const DModule& from);

  inline DModule& operator=(const DModule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DModule& default_instance();

  void Swap(DModule* other);

  // implements Message ----------------------------------------------

  DModule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DModule& from);
  void MergeFrom(const DModule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DModule_TArch TArch;
  typedef DModule_ConstantValue ConstantValue;
  typedef DModule_TVar TVar;
  typedef DModule_RegArray RegArray;
  typedef DModule_Expression Expression;
  typedef DModule_Register Register;
  typedef DModule_Statement Statement;
  typedef DModule_DBlock DBlock;

  typedef DModule_TArchMajor TArchMajor;
  static const TArchMajor TA_MA_INVALID = DModule_TArchMajor_TA_MA_INVALID;
  static const TArchMajor X86 = DModule_TArchMajor_X86;
  static const TArchMajor AMD64 = DModule_TArchMajor_AMD64;
  static const TArchMajor ARM = DModule_TArchMajor_ARM;
  static const TArchMajor PPC32 = DModule_TArchMajor_PPC32;
  static const TArchMajor PPC64 = DModule_TArchMajor_PPC64;
  static const TArchMajor S390X = DModule_TArchMajor_S390X;
  static inline bool TArchMajor_IsValid(int value) {
    return DModule_TArchMajor_IsValid(value);
  }
  static const TArchMajor TArchMajor_MIN =
    DModule_TArchMajor_TArchMajor_MIN;
  static const TArchMajor TArchMajor_MAX =
    DModule_TArchMajor_TArchMajor_MAX;
  static const int TArchMajor_ARRAYSIZE =
    DModule_TArchMajor_TArchMajor_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TArchMajor_descriptor() {
    return DModule_TArchMajor_descriptor();
  }
  static inline const ::std::string& TArchMajor_Name(TArchMajor value) {
    return DModule_TArchMajor_Name(value);
  }
  static inline bool TArchMajor_Parse(const ::std::string& name,
      TArchMajor* value) {
    return DModule_TArchMajor_Parse(name, value);
  }

  typedef DModule_TArchMinor TArchMinor;
  static const TArchMinor TA_MI_INVALID = DModule_TArchMinor_TA_MI_INVALID;
  static const TArchMinor WIDEARM = DModule_TArchMinor_WIDEARM;
  static const TArchMinor THUMB = DModule_TArchMinor_THUMB;
  static inline bool TArchMinor_IsValid(int value) {
    return DModule_TArchMinor_IsValid(value);
  }
  static const TArchMinor TArchMinor_MIN =
    DModule_TArchMinor_TArchMinor_MIN;
  static const TArchMinor TArchMinor_MAX =
    DModule_TArchMinor_TArchMinor_MAX;
  static const int TArchMinor_ARRAYSIZE =
    DModule_TArchMinor_TArchMinor_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TArchMinor_descriptor() {
    return DModule_TArchMinor_descriptor();
  }
  static inline const ::std::string& TArchMinor_Name(TArchMinor value) {
    return DModule_TArchMinor_Name(value);
  }
  static inline bool TArchMinor_Parse(const ::std::string& name,
      TArchMinor* value) {
    return DModule_TArchMinor_Parse(name, value);
  }

  typedef DModule_Ops Ops;
  static const Ops Add = DModule_Ops_Add;
  static const Ops Sub = DModule_Ops_Sub;
  static const Ops Mul = DModule_Ops_Mul;
  static const Ops MulU = DModule_Ops_MulU;
  static const Ops MulS = DModule_Ops_MulS;
  static const Ops Or = DModule_Ops_Or;
  static const Ops And = DModule_Ops_And;
  static const Ops Xor = DModule_Ops_Xor;
  static const Ops Shl = DModule_Ops_Shl;
  static const Ops Shr = DModule_Ops_Shr;
  static const Ops Sar = DModule_Ops_Sar;
  static const Ops CmpEQ = DModule_Ops_CmpEQ;
  static const Ops CmpNE = DModule_Ops_CmpNE;
  static const Ops CmpLTS = DModule_Ops_CmpLTS;
  static const Ops CmpLTU = DModule_Ops_CmpLTU;
  static const Ops CmpLES = DModule_Ops_CmpLES;
  static const Ops CmpLEU = DModule_Ops_CmpLEU;
  static const Ops Not = DModule_Ops_Not;
  static const Ops CF32toF64 = DModule_Ops_CF32toF64;
  static const Ops C64to8 = DModule_Ops_C64to8;
  static const Ops C32to8 = DModule_Ops_C32to8;
  static const Ops C64to16 = DModule_Ops_C64to16;
  static const Ops C64LOto32 = DModule_Ops_C64LOto32;
  static const Ops C64HIto32 = DModule_Ops_C64HIto32;
  static const Ops C32LOto16 = DModule_Ops_C32LOto16;
  static const Ops C32HIto16 = DModule_Ops_C32HIto16;
  static const Ops C16LOto8 = DModule_Ops_C16LOto8;
  static const Ops C16HIto8 = DModule_Ops_C16HIto8;
  static const Ops C16HLto32 = DModule_Ops_C16HLto32;
  static const Ops C1Uto32 = DModule_Ops_C1Uto32;
  static const Ops C1Uto8 = DModule_Ops_C1Uto8;
  static const Ops C8Uto32 = DModule_Ops_C8Uto32;
  static const Ops C8Sto32 = DModule_Ops_C8Sto32;
  static const Ops C8Uto16 = DModule_Ops_C8Uto16;
  static const Ops C8Sto16 = DModule_Ops_C8Sto16;
  static const Ops C8Uto64 = DModule_Ops_C8Uto64;
  static const Ops C16Uto64 = DModule_Ops_C16Uto64;
  static const Ops C16Uto32 = DModule_Ops_C16Uto32;
  static const Ops C16Sto32 = DModule_Ops_C16Sto32;
  static const Ops C32Uto64 = DModule_Ops_C32Uto64;
  static const Ops C32Sto64 = DModule_Ops_C32Sto64;
  static const Ops C32HLto64 = DModule_Ops_C32HLto64;
  static const Ops C32to1 = DModule_Ops_C32to1;
  static const Ops C64to1 = DModule_Ops_C64to1;
  static const Ops DivModS64to32 = DModule_Ops_DivModS64to32;
  static const Ops DivModU64to32 = DModule_Ops_DivModU64to32;
  static const Ops Sad8Ux4 = DModule_Ops_Sad8Ux4;
  static const Ops Add8x8 = DModule_Ops_Add8x8;
  static const Ops Add16x4 = DModule_Ops_Add16x4;
  static const Ops Add32x2 = DModule_Ops_Add32x2;
  static const Ops Add64x1 = DModule_Ops_Add64x1;
  static const Ops QAdd8Sx8 = DModule_Ops_QAdd8Sx8;
  static const Ops QAdd16Sx4 = DModule_Ops_QAdd16Sx4;
  static const Ops QAdd32Sx2 = DModule_Ops_QAdd32Sx2;
  static const Ops QAdd64Sx1 = DModule_Ops_QAdd64Sx1;
  static const Ops QAdd8Ux8 = DModule_Ops_QAdd8Ux8;
  static const Ops QAdd16Ux4 = DModule_Ops_QAdd16Ux4;
  static const Ops QAdd32Ux2 = DModule_Ops_QAdd32Ux2;
  static const Ops QAdd64Ux1 = DModule_Ops_QAdd64Ux1;
  static const Ops Sub8x8 = DModule_Ops_Sub8x8;
  static const Ops Sub16x4 = DModule_Ops_Sub16x4;
  static const Ops Sub32x2 = DModule_Ops_Sub32x2;
  static const Ops QSub8Sx8 = DModule_Ops_QSub8Sx8;
  static const Ops QSub16Sx4 = DModule_Ops_QSub16Sx4;
  static const Ops QSub32Sx2 = DModule_Ops_QSub32Sx2;
  static const Ops QSub64Sx1 = DModule_Ops_QSub64Sx1;
  static const Ops QSub8Ux8 = DModule_Ops_QSub8Ux8;
  static const Ops QSub16Ux4 = DModule_Ops_QSub16Ux4;
  static const Ops QSub32Ux2 = DModule_Ops_QSub32Ux2;
  static const Ops QSub64Ux1 = DModule_Ops_QSub64Ux1;
  static const Ops CmpEQ8x8 = DModule_Ops_CmpEQ8x8;
  static const Ops CmpEQ16x4 = DModule_Ops_CmpEQ16x4;
  static const Ops CmpEQ32x2 = DModule_Ops_CmpEQ32x2;
  static const Ops CmpGT8Ux8 = DModule_Ops_CmpGT8Ux8;
  static const Ops CmpGT16Ux4 = DModule_Ops_CmpGT16Ux4;
  static const Ops CmpGT32Ux2 = DModule_Ops_CmpGT32Ux2;
  static const Ops CmpGT8Sx8 = DModule_Ops_CmpGT8Sx8;
  static const Ops CmpGT16Sx4 = DModule_Ops_CmpGT16Sx4;
  static const Ops CmpGT32Sx2 = DModule_Ops_CmpGT32Sx2;
  static const Ops ShlN8x8 = DModule_Ops_ShlN8x8;
  static const Ops ShlN16x4 = DModule_Ops_ShlN16x4;
  static const Ops ShlN32x2 = DModule_Ops_ShlN32x2;
  static const Ops ShrN8x8 = DModule_Ops_ShrN8x8;
  static const Ops ShrN16x4 = DModule_Ops_ShrN16x4;
  static const Ops ShrN32x2 = DModule_Ops_ShrN32x2;
  static const Ops SarN8x8 = DModule_Ops_SarN8x8;
  static const Ops SarN16x4 = DModule_Ops_SarN16x4;
  static const Ops SarN32x2 = DModule_Ops_SarN32x2;
  static const Ops Mul8x8 = DModule_Ops_Mul8x8;
  static const Ops Mul16x4 = DModule_Ops_Mul16x4;
  static const Ops Mul32x2 = DModule_Ops_Mul32x2;
  static const Ops Mul32Fx2 = DModule_Ops_Mul32Fx2;
  static const Ops MulHi16Ux4 = DModule_Ops_MulHi16Ux4;
  static const Ops MulHi16Sx4 = DModule_Ops_MulHi16Sx4;
  static const Ops PolyMul8x8 = DModule_Ops_PolyMul8x8;
  static const Ops InterleaveHI8x8 = DModule_Ops_InterleaveHI8x8;
  static const Ops InterleaveHI16x4 = DModule_Ops_InterleaveHI16x4;
  static const Ops InterleaveHI32x2 = DModule_Ops_InterleaveHI32x2;
  static const Ops InterleaveLO8x8 = DModule_Ops_InterleaveLO8x8;
  static const Ops InterleaveLO16x4 = DModule_Ops_InterleaveLO16x4;
  static const Ops InterleaveLO32x2 = DModule_Ops_InterleaveLO32x2;
  static const Ops InterleaveOddLanes8x8 = DModule_Ops_InterleaveOddLanes8x8;
  static const Ops InterleaveEvenLanes8x8 = DModule_Ops_InterleaveEvenLanes8x8;
  static const Ops InterleaveOddLanes16x4 = DModule_Ops_InterleaveOddLanes16x4;
  static const Ops InterleaveEvenLanes16x4 = DModule_Ops_InterleaveEvenLanes16x4;
  static const Ops Abs8x16 = DModule_Ops_Abs8x16;
  static const Ops Abs16x8 = DModule_Ops_Abs16x8;
  static const Ops Abs32x4 = DModule_Ops_Abs32x4;
  static const Ops Avg8Ux16 = DModule_Ops_Avg8Ux16;
  static const Ops Avg16Ux8 = DModule_Ops_Avg16Ux8;
  static const Ops Avg32Ux4 = DModule_Ops_Avg32Ux4;
  static const Ops Avg8Sx16 = DModule_Ops_Avg8Sx16;
  static const Ops Avg16Sx8 = DModule_Ops_Avg16Sx8;
  static const Ops Avg32Sx4 = DModule_Ops_Avg32Sx4;
  static const Ops Max8Sx16 = DModule_Ops_Max8Sx16;
  static const Ops Max16Sx8 = DModule_Ops_Max16Sx8;
  static const Ops Max32Sx4 = DModule_Ops_Max32Sx4;
  static const Ops Max8Ux16 = DModule_Ops_Max8Ux16;
  static const Ops Max16Ux8 = DModule_Ops_Max16Ux8;
  static const Ops Max32Ux4 = DModule_Ops_Max32Ux4;
  static const Ops Min8Sx16 = DModule_Ops_Min8Sx16;
  static const Ops Min16Sx8 = DModule_Ops_Min16Sx8;
  static const Ops Min32Sx4 = DModule_Ops_Min32Sx4;
  static const Ops Min8Ux16 = DModule_Ops_Min8Ux16;
  static const Ops Min16Ux8 = DModule_Ops_Min16Ux8;
  static const Ops Min32Ux4 = DModule_Ops_Min32Ux4;
  static const Ops Min8Ux8 = DModule_Ops_Min8Ux8;
  static const Ops Min16Ux4 = DModule_Ops_Min16Ux4;
  static const Ops Min32Ux2 = DModule_Ops_Min32Ux2;
  static const Ops Max8Sx8 = DModule_Ops_Max8Sx8;
  static const Ops Max16Sx4 = DModule_Ops_Max16Sx4;
  static const Ops Max32Sx2 = DModule_Ops_Max32Sx2;
  static const Ops Max8Ux8 = DModule_Ops_Max8Ux8;
  static const Ops Max16Ux4 = DModule_Ops_Max16Ux4;
  static const Ops Max32Ux2 = DModule_Ops_Max32Ux2;
  static const Ops Min8Sx8 = DModule_Ops_Min8Sx8;
  static const Ops Min16Sx4 = DModule_Ops_Min16Sx4;
  static const Ops Min32Sx2 = DModule_Ops_Min32Sx2;
  static const Ops QNarrow16Ux4 = DModule_Ops_QNarrow16Ux4;
  static const Ops QNarrow16Sx4 = DModule_Ops_QNarrow16Sx4;
  static const Ops QNarrow32Sx2 = DModule_Ops_QNarrow32Sx2;
  static const Ops UNSUP = DModule_Ops_UNSUP;
  static inline bool Ops_IsValid(int value) {
    return DModule_Ops_IsValid(value);
  }
  static const Ops Ops_MIN =
    DModule_Ops_Ops_MIN;
  static const Ops Ops_MAX =
    DModule_Ops_Ops_MAX;
  static const int Ops_ARRAYSIZE =
    DModule_Ops_Ops_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Ops_descriptor() {
    return DModule_Ops_descriptor();
  }
  static inline const ::std::string& Ops_Name(Ops value) {
    return DModule_Ops_Name(value);
  }
  static inline bool Ops_Parse(const ::std::string& name,
      Ops* value) {
    return DModule_Ops_Parse(name, value);
  }

  typedef DModule_ExType ExType;
  static const ExType Const = DModule_ExType_Const;
  static const ExType RdTmp = DModule_ExType_RdTmp;
  static const ExType Op = DModule_ExType_Op;
  static const ExType Load = DModule_ExType_Load;
  static const ExType Mux0X = DModule_ExType_Mux0X;
  static const ExType CCall = DModule_ExType_CCall;
  static const ExType Get = DModule_ExType_Get;
  static inline bool ExType_IsValid(int value) {
    return DModule_ExType_IsValid(value);
  }
  static const ExType ExType_MIN =
    DModule_ExType_ExType_MIN;
  static const ExType ExType_MAX =
    DModule_ExType_ExType_MAX;
  static const int ExType_ARRAYSIZE =
    DModule_ExType_ExType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ExType_descriptor() {
    return DModule_ExType_descriptor();
  }
  static inline const ::std::string& ExType_Name(ExType value) {
    return DModule_ExType_Name(value);
  }
  static inline bool ExType_Parse(const ::std::string& name,
      ExType* value) {
    return DModule_ExType_Parse(name, value);
  }

  typedef DModule_ValTy ValTy;
  static const ValTy T_INVALID = DModule_ValTy_T_INVALID;
  static const ValTy T_I1 = DModule_ValTy_T_I1;
  static const ValTy T_I8 = DModule_ValTy_T_I8;
  static const ValTy T_I16 = DModule_ValTy_T_I16;
  static const ValTy T_I32 = DModule_ValTy_T_I32;
  static const ValTy T_I64 = DModule_ValTy_T_I64;
  static const ValTy T_I128 = DModule_ValTy_T_I128;
  static const ValTy T_F32 = DModule_ValTy_T_F32;
  static const ValTy T_F64 = DModule_ValTy_T_F64;
  static const ValTy T_F128 = DModule_ValTy_T_F128;
  static const ValTy T_V128 = DModule_ValTy_T_V128;
  static inline bool ValTy_IsValid(int value) {
    return DModule_ValTy_IsValid(value);
  }
  static const ValTy ValTy_MIN =
    DModule_ValTy_ValTy_MIN;
  static const ValTy ValTy_MAX =
    DModule_ValTy_ValTy_MAX;
  static const int ValTy_ARRAYSIZE =
    DModule_ValTy_ValTy_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ValTy_descriptor() {
    return DModule_ValTy_descriptor();
  }
  static inline const ::std::string& ValTy_Name(ValTy value) {
    return DModule_ValTy_Name(value);
  }
  static inline bool ValTy_Parse(const ::std::string& name,
      ValTy* value) {
    return DModule_ValTy_Parse(name, value);
  }

  typedef DModule_StType StType;
  static const StType WrTmp = DModule_StType_WrTmp;
  static const StType Store = DModule_StType_Store;
  static const StType CAS = DModule_StType_CAS;
  static const StType Put = DModule_StType_Put;
  static const StType LLSC = DModule_StType_LLSC;
  static const StType Dirty = DModule_StType_Dirty;
  static const StType Exit = DModule_StType_Exit;
  static const StType IMark = DModule_StType_IMark;
  static const StType NOP = DModule_StType_NOP;
  static const StType AbiHint = DModule_StType_AbiHint;
  static const StType MBE = DModule_StType_MBE;
  static inline bool StType_IsValid(int value) {
    return DModule_StType_IsValid(value);
  }
  static const StType StType_MIN =
    DModule_StType_StType_MIN;
  static const StType StType_MAX =
    DModule_StType_StType_MAX;
  static const int StType_ARRAYSIZE =
    DModule_StType_StType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StType_descriptor() {
    return DModule_StType_descriptor();
  }
  static inline const ::std::string& StType_Name(StType value) {
    return DModule_StType_Name(value);
  }
  static inline bool StType_Parse(const ::std::string& name,
      StType* value) {
    return DModule_StType_Parse(name, value);
  }

  typedef DModule_ExitType ExitType;
  static const ExitType Fallthrough = DModule_ExitType_Fallthrough;
  static const ExitType Call = DModule_ExitType_Call;
  static const ExitType Return = DModule_ExitType_Return;
  static const ExitType UnknownExit = DModule_ExitType_UnknownExit;
  static inline bool ExitType_IsValid(int value) {
    return DModule_ExitType_IsValid(value);
  }
  static const ExitType ExitType_MIN =
    DModule_ExitType_ExitType_MIN;
  static const ExitType ExitType_MAX =
    DModule_ExitType_ExitType_MAX;
  static const int ExitType_ARRAYSIZE =
    DModule_ExitType_ExitType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ExitType_descriptor() {
    return DModule_ExitType_descriptor();
  }
  static inline const ::std::string& ExitType_Name(ExitType value) {
    return DModule_ExitType_Name(value);
  }
  static inline bool ExitType_Parse(const ::std::string& name,
      ExitType* value) {
    return DModule_ExitType_Parse(name, value);
  }

  typedef DModule_MemoryEnd MemoryEnd;
  static const MemoryEnd BigEndian = DModule_MemoryEnd_BigEndian;
  static const MemoryEnd LittleEndian = DModule_MemoryEnd_LittleEndian;
  static inline bool MemoryEnd_IsValid(int value) {
    return DModule_MemoryEnd_IsValid(value);
  }
  static const MemoryEnd MemoryEnd_MIN =
    DModule_MemoryEnd_MemoryEnd_MIN;
  static const MemoryEnd MemoryEnd_MAX =
    DModule_MemoryEnd_MemoryEnd_MAX;
  static const int MemoryEnd_ARRAYSIZE =
    DModule_MemoryEnd_MemoryEnd_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MemoryEnd_descriptor() {
    return DModule_MemoryEnd_descriptor();
  }
  static inline const ::std::string& MemoryEnd_Name(MemoryEnd value) {
    return DModule_MemoryEnd_Name(value);
  }
  static inline bool MemoryEnd_Parse(const ::std::string& name,
      MemoryEnd* value) {
    return DModule_MemoryEnd_Parse(name, value);
  }

  typedef DModule_RegisterClass RegisterClass;
  static const RegisterClass GenericRegister = DModule_RegisterClass_GenericRegister;
  static const RegisterClass StackPointer = DModule_RegisterClass_StackPointer;
  static const RegisterClass ProgramCounter = DModule_RegisterClass_ProgramCounter;
  static const RegisterClass Flags = DModule_RegisterClass_Flags;
  static const RegisterClass InternalState = DModule_RegisterClass_InternalState;
  static inline bool RegisterClass_IsValid(int value) {
    return DModule_RegisterClass_IsValid(value);
  }
  static const RegisterClass RegisterClass_MIN =
    DModule_RegisterClass_RegisterClass_MIN;
  static const RegisterClass RegisterClass_MAX =
    DModule_RegisterClass_RegisterClass_MAX;
  static const int RegisterClass_ARRAYSIZE =
    DModule_RegisterClass_RegisterClass_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RegisterClass_descriptor() {
    return DModule_RegisterClass_descriptor();
  }
  static inline const ::std::string& RegisterClass_Name(RegisterClass value) {
    return DModule_RegisterClass_Name(value);
  }
  static inline bool RegisterClass_Parse(const ::std::string& name,
      RegisterClass* value) {
    return DModule_RegisterClass_Parse(name, value);
  }

  typedef DModule_x86reg_8 x86reg_8;
  static const x86reg_8 AL = DModule_x86reg_8_AL;
  static const x86reg_8 AH = DModule_x86reg_8_AH;
  static const x86reg_8 BL = DModule_x86reg_8_BL;
  static const x86reg_8 BH = DModule_x86reg_8_BH;
  static const x86reg_8 CL = DModule_x86reg_8_CL;
  static const x86reg_8 CH = DModule_x86reg_8_CH;
  static const x86reg_8 DL = DModule_x86reg_8_DL;
  static const x86reg_8 DH = DModule_x86reg_8_DH;
  static inline bool x86reg_8_IsValid(int value) {
    return DModule_x86reg_8_IsValid(value);
  }
  static const x86reg_8 x86reg_8_MIN =
    DModule_x86reg_8_x86reg_8_MIN;
  static const x86reg_8 x86reg_8_MAX =
    DModule_x86reg_8_x86reg_8_MAX;
  static const int x86reg_8_ARRAYSIZE =
    DModule_x86reg_8_x86reg_8_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  x86reg_8_descriptor() {
    return DModule_x86reg_8_descriptor();
  }
  static inline const ::std::string& x86reg_8_Name(x86reg_8 value) {
    return DModule_x86reg_8_Name(value);
  }
  static inline bool x86reg_8_Parse(const ::std::string& name,
      x86reg_8* value) {
    return DModule_x86reg_8_Parse(name, value);
  }

  typedef DModule_x86reg_16 x86reg_16;
  static const x86reg_16 AX = DModule_x86reg_16_AX;
  static const x86reg_16 BX = DModule_x86reg_16_BX;
  static const x86reg_16 CX = DModule_x86reg_16_CX;
  static const x86reg_16 DX = DModule_x86reg_16_DX;
  static const x86reg_16 BP = DModule_x86reg_16_BP;
  static const x86reg_16 SI = DModule_x86reg_16_SI;
  static const x86reg_16 DI = DModule_x86reg_16_DI;
  static const x86reg_16 SP = DModule_x86reg_16_SP;
  static inline bool x86reg_16_IsValid(int value) {
    return DModule_x86reg_16_IsValid(value);
  }
  static const x86reg_16 x86reg_16_MIN =
    DModule_x86reg_16_x86reg_16_MIN;
  static const x86reg_16 x86reg_16_MAX =
    DModule_x86reg_16_x86reg_16_MAX;
  static const int x86reg_16_ARRAYSIZE =
    DModule_x86reg_16_x86reg_16_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  x86reg_16_descriptor() {
    return DModule_x86reg_16_descriptor();
  }
  static inline const ::std::string& x86reg_16_Name(x86reg_16 value) {
    return DModule_x86reg_16_Name(value);
  }
  static inline bool x86reg_16_Parse(const ::std::string& name,
      x86reg_16* value) {
    return DModule_x86reg_16_Parse(name, value);
  }

  typedef DModule_x86reg_32 x86reg_32;
  static const x86reg_32 EAX = DModule_x86reg_32_EAX;
  static const x86reg_32 EBX = DModule_x86reg_32_EBX;
  static const x86reg_32 ECX = DModule_x86reg_32_ECX;
  static const x86reg_32 EDX = DModule_x86reg_32_EDX;
  static const x86reg_32 EDI = DModule_x86reg_32_EDI;
  static const x86reg_32 ESI = DModule_x86reg_32_ESI;
  static const x86reg_32 EBP = DModule_x86reg_32_EBP;
  static const x86reg_32 ESP = DModule_x86reg_32_ESP;
  static const x86reg_32 EIP = DModule_x86reg_32_EIP;
  static const x86reg_32 CS = DModule_x86reg_32_CS;
  static const x86reg_32 DS = DModule_x86reg_32_DS;
  static const x86reg_32 ES = DModule_x86reg_32_ES;
  static const x86reg_32 FS = DModule_x86reg_32_FS;
  static const x86reg_32 GS = DModule_x86reg_32_GS;
  static const x86reg_32 SS = DModule_x86reg_32_SS;
  static const x86reg_32 OP = DModule_x86reg_32_OP;
  static const x86reg_32 DEP1 = DModule_x86reg_32_DEP1;
  static const x86reg_32 DEP2 = DModule_x86reg_32_DEP2;
  static const x86reg_32 NDEP = DModule_x86reg_32_NDEP;
  static const x86reg_32 DFLAG = DModule_x86reg_32_DFLAG;
  static const x86reg_32 IDFLAG = DModule_x86reg_32_IDFLAG;
  static const x86reg_32 ACFLAG = DModule_x86reg_32_ACFLAG;
  static const x86reg_32 FTOP = DModule_x86reg_32_FTOP;
  static const x86reg_32 LDT32 = DModule_x86reg_32_LDT32;
  static const x86reg_32 GDT32 = DModule_x86reg_32_GDT32;
  static const x86reg_32 EMWARN32 = DModule_x86reg_32_EMWARN32;
  static inline bool x86reg_32_IsValid(int value) {
    return DModule_x86reg_32_IsValid(value);
  }
  static const x86reg_32 x86reg_32_MIN =
    DModule_x86reg_32_x86reg_32_MIN;
  static const x86reg_32 x86reg_32_MAX =
    DModule_x86reg_32_x86reg_32_MAX;
  static const int x86reg_32_ARRAYSIZE =
    DModule_x86reg_32_x86reg_32_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  x86reg_32_descriptor() {
    return DModule_x86reg_32_descriptor();
  }
  static inline const ::std::string& x86reg_32_Name(x86reg_32 value) {
    return DModule_x86reg_32_Name(value);
  }
  static inline bool x86reg_32_Parse(const ::std::string& name,
      x86reg_32* value) {
    return DModule_x86reg_32_Parse(name, value);
  }

  typedef DModule_x86reg_64 x86reg_64;
  static const x86reg_64 RAX = DModule_x86reg_64_RAX;
  static const x86reg_64 RBX = DModule_x86reg_64_RBX;
  static const x86reg_64 RCX = DModule_x86reg_64_RCX;
  static const x86reg_64 RDX = DModule_x86reg_64_RDX;
  static const x86reg_64 RDI = DModule_x86reg_64_RDI;
  static const x86reg_64 RSI = DModule_x86reg_64_RSI;
  static const x86reg_64 RSP = DModule_x86reg_64_RSP;
  static const x86reg_64 RBP = DModule_x86reg_64_RBP;
  static const x86reg_64 RIP = DModule_x86reg_64_RIP;
  static const x86reg_64 R8 = DModule_x86reg_64_R8;
  static const x86reg_64 R9 = DModule_x86reg_64_R9;
  static const x86reg_64 R10 = DModule_x86reg_64_R10;
  static const x86reg_64 R11 = DModule_x86reg_64_R11;
  static const x86reg_64 R12 = DModule_x86reg_64_R12;
  static const x86reg_64 R13 = DModule_x86reg_64_R13;
  static const x86reg_64 R14 = DModule_x86reg_64_R14;
  static const x86reg_64 R15 = DModule_x86reg_64_R15;
  static const x86reg_64 GDT = DModule_x86reg_64_GDT;
  static const x86reg_64 LDT = DModule_x86reg_64_LDT;
  static inline bool x86reg_64_IsValid(int value) {
    return DModule_x86reg_64_IsValid(value);
  }
  static const x86reg_64 x86reg_64_MIN =
    DModule_x86reg_64_x86reg_64_MIN;
  static const x86reg_64 x86reg_64_MAX =
    DModule_x86reg_64_x86reg_64_MAX;
  static const int x86reg_64_ARRAYSIZE =
    DModule_x86reg_64_x86reg_64_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  x86reg_64_descriptor() {
    return DModule_x86reg_64_descriptor();
  }
  static inline const ::std::string& x86reg_64_Name(x86reg_64 value) {
    return DModule_x86reg_64_Name(value);
  }
  static inline bool x86reg_64_Parse(const ::std::string& name,
      x86reg_64* value) {
    return DModule_x86reg_64_Parse(name, value);
  }

  typedef DModule_armreg armreg;
  static const armreg AR1 = DModule_armreg_AR1;
  static const armreg AR2 = DModule_armreg_AR2;
  static const armreg AR3 = DModule_armreg_AR3;
  static const armreg AR4 = DModule_armreg_AR4;
  static const armreg AR5 = DModule_armreg_AR5;
  static const armreg AR6 = DModule_armreg_AR6;
  static const armreg AR7 = DModule_armreg_AR7;
  static const armreg AR8 = DModule_armreg_AR8;
  static const armreg AR9 = DModule_armreg_AR9;
  static const armreg AR10 = DModule_armreg_AR10;
  static const armreg AR11 = DModule_armreg_AR11;
  static const armreg AR12 = DModule_armreg_AR12;
  static const armreg AR13 = DModule_armreg_AR13;
  static const armreg AR14 = DModule_armreg_AR14;
  static const armreg AR15 = DModule_armreg_AR15;
  static inline bool armreg_IsValid(int value) {
    return DModule_armreg_IsValid(value);
  }
  static const armreg armreg_MIN =
    DModule_armreg_armreg_MIN;
  static const armreg armreg_MAX =
    DModule_armreg_armreg_MAX;
  static const int armreg_ARRAYSIZE =
    DModule_armreg_armreg_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  armreg_descriptor() {
    return DModule_armreg_descriptor();
  }
  static inline const ::std::string& armreg_Name(armreg value) {
    return DModule_armreg_Name(value);
  }
  static inline bool armreg_Parse(const ::std::string& name,
      armreg* value) {
    return DModule_armreg_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string fileName = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // repeated .DModule.DBlock blocks = 2;
  inline int blocks_size() const;
  inline void clear_blocks();
  static const int kBlocksFieldNumber = 2;
  inline const ::DModule_DBlock& blocks(int index) const;
  inline ::DModule_DBlock* mutable_blocks(int index);
  inline ::DModule_DBlock* add_blocks();
  inline const ::google::protobuf::RepeatedPtrField< ::DModule_DBlock >&
      blocks() const;
  inline ::google::protobuf::RepeatedPtrField< ::DModule_DBlock >*
      mutable_blocks();

  // @@protoc_insertion_point(class_scope:DModule)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* filename_;
  ::google::protobuf::RepeatedPtrField< ::DModule_DBlock > blocks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_IR_2eproto();
  friend void protobuf_AssignDesc_IR_2eproto();
  friend void protobuf_ShutdownFile_IR_2eproto();

  void InitAsDefaultInstance();
  static DModule* default_instance_;
};
// ===================================================================


// ===================================================================

// DModule_TArch

// required .DModule.TArchMajor major = 1;
inline bool DModule_TArch::has_major() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DModule_TArch::set_has_major() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DModule_TArch::clear_has_major() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DModule_TArch::clear_major() {
  major_ = 0;
  clear_has_major();
}
inline ::DModule_TArchMajor DModule_TArch::major() const {
  return static_cast< ::DModule_TArchMajor >(major_);
}
inline void DModule_TArch::set_major(::DModule_TArchMajor value) {
  assert(::DModule_TArchMajor_IsValid(value));
  set_has_major();
  major_ = value;
}

// required .DModule.TArchMinor minor = 2;
inline bool DModule_TArch::has_minor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DModule_TArch::set_has_minor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DModule_TArch::clear_has_minor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DModule_TArch::clear_minor() {
  minor_ = 0;
  clear_has_minor();
}
inline ::DModule_TArchMinor DModule_TArch::minor() const {
  return static_cast< ::DModule_TArchMinor >(minor_);
}
inline void DModule_TArch::set_minor(::DModule_TArchMinor value) {
  assert(::DModule_TArchMinor_IsValid(value));
  set_has_minor();
  minor_ = value;
}

// -------------------------------------------------------------------

// DModule_ConstantValue

// required .DModule.ValTy ty = 1;
inline bool DModule_ConstantValue::has_ty() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DModule_ConstantValue::set_has_ty() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DModule_ConstantValue::clear_has_ty() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DModule_ConstantValue::clear_ty() {
  ty_ = 0;
  clear_has_ty();
}
inline ::DModule_ValTy DModule_ConstantValue::ty() const {
  return static_cast< ::DModule_ValTy >(ty_);
}
inline void DModule_ConstantValue::set_ty(::DModule_ValTy value) {
  assert(::DModule_ValTy_IsValid(value));
  set_has_ty();
  ty_ = value;
}

// required bool isKnown = 2;
inline bool DModule_ConstantValue::has_isknown() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DModule_ConstantValue::set_has_isknown() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DModule_ConstantValue::clear_has_isknown() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DModule_ConstantValue::clear_isknown() {
  isknown_ = false;
  clear_has_isknown();
}
inline bool DModule_ConstantValue::isknown() const {
  return isknown_;
}
inline void DModule_ConstantValue::set_isknown(bool value) {
  set_has_isknown();
  isknown_ = value;
}

// required int32 width = 3;
inline bool DModule_ConstantValue::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DModule_ConstantValue::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DModule_ConstantValue::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DModule_ConstantValue::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 DModule_ConstantValue::width() const {
  return width_;
}
inline void DModule_ConstantValue::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// optional int64 val = 4;
inline bool DModule_ConstantValue::has_val() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DModule_ConstantValue::set_has_val() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DModule_ConstantValue::clear_has_val() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DModule_ConstantValue::clear_val() {
  val_ = GOOGLE_LONGLONG(0);
  clear_has_val();
}
inline ::google::protobuf::int64 DModule_ConstantValue::val() const {
  return val_;
}
inline void DModule_ConstantValue::set_val(::google::protobuf::int64 value) {
  set_has_val();
  val_ = value;
}

// -------------------------------------------------------------------

// DModule_TVar

// required int32 varIdx = 1;
inline bool DModule_TVar::has_varidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DModule_TVar::set_has_varidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DModule_TVar::clear_has_varidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DModule_TVar::clear_varidx() {
  varidx_ = 0;
  clear_has_varidx();
}
inline ::google::protobuf::int32 DModule_TVar::varidx() const {
  return varidx_;
}
inline void DModule_TVar::set_varidx(::google::protobuf::int32 value) {
  set_has_varidx();
  varidx_ = value;
}

// required int32 width = 2;
inline bool DModule_TVar::has_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DModule_TVar::set_has_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DModule_TVar::clear_has_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DModule_TVar::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 DModule_TVar::width() const {
  return width_;
}
inline void DModule_TVar::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// required .DModule.ValTy ty = 3;
inline bool DModule_TVar::has_ty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DModule_TVar::set_has_ty() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DModule_TVar::clear_has_ty() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DModule_TVar::clear_ty() {
  ty_ = 0;
  clear_has_ty();
}
inline ::DModule_ValTy DModule_TVar::ty() const {
  return static_cast< ::DModule_ValTy >(ty_);
}
inline void DModule_TVar::set_ty(::DModule_ValTy value) {
  assert(::DModule_ValTy_IsValid(value));
  set_has_ty();
  ty_ = value;
}

// -------------------------------------------------------------------

// DModule_RegArray

// required int32 base = 1;
inline bool DModule_RegArray::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DModule_RegArray::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DModule_RegArray::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DModule_RegArray::clear_base() {
  base_ = 0;
  clear_has_base();
}
inline ::google::protobuf::int32 DModule_RegArray::base() const {
  return base_;
}
inline void DModule_RegArray::set_base(::google::protobuf::int32 value) {
  set_has_base();
  base_ = value;
}

// required .DModule.ValTy ty = 2;
inline bool DModule_RegArray::has_ty() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DModule_RegArray::set_has_ty() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DModule_RegArray::clear_has_ty() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DModule_RegArray::clear_ty() {
  ty_ = 0;
  clear_has_ty();
}
inline ::DModule_ValTy DModule_RegArray::ty() const {
  return static_cast< ::DModule_ValTy >(ty_);
}
inline void DModule_RegArray::set_ty(::DModule_ValTy value) {
  assert(::DModule_ValTy_IsValid(value));
  set_has_ty();
  ty_ = value;
}

// required int32 numElems = 3;
inline bool DModule_RegArray::has_numelems() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DModule_RegArray::set_has_numelems() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DModule_RegArray::clear_has_numelems() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DModule_RegArray::clear_numelems() {
  numelems_ = 0;
  clear_has_numelems();
}
inline ::google::protobuf::int32 DModule_RegArray::numelems() const {
  return numelems_;
}
inline void DModule_RegArray::set_numelems(::google::protobuf::int32 value) {
  set_has_numelems();
  numelems_ = value;
}

// -------------------------------------------------------------------

// DModule_Expression

// required .DModule.ExType ty = 1;
inline bool DModule_Expression::has_ty() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DModule_Expression::set_has_ty() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DModule_Expression::clear_has_ty() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DModule_Expression::clear_ty() {
  ty_ = 0;
  clear_has_ty();
}
inline ::DModule_ExType DModule_Expression::ty() const {
  return static_cast< ::DModule_ExType >(ty_);
}
inline void DModule_Expression::set_ty(::DModule_ExType value) {
  assert(::DModule_ExType_IsValid(value));
  set_has_ty();
  ty_ = value;
}

// optional .DModule.Ops Op_opcode = 2;
inline bool DModule_Expression::has_op_opcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DModule_Expression::set_has_op_opcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DModule_Expression::clear_has_op_opcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DModule_Expression::clear_op_opcode() {
  op_opcode_ = 0;
  clear_has_op_opcode();
}
inline ::DModule_Ops DModule_Expression::op_opcode() const {
  return static_cast< ::DModule_Ops >(op_opcode_);
}
inline void DModule_Expression::set_op_opcode(::DModule_Ops value) {
  assert(::DModule_Ops_IsValid(value));
  set_has_op_opcode();
  op_opcode_ = value;
}

// repeated .DModule.Expression Op_arguments = 3;
inline int DModule_Expression::op_arguments_size() const {
  return op_arguments_.size();
}
inline void DModule_Expression::clear_op_arguments() {
  op_arguments_.Clear();
}
inline const ::DModule_Expression& DModule_Expression::op_arguments(int index) const {
  return op_arguments_.Get(index);
}
inline ::DModule_Expression* DModule_Expression::mutable_op_arguments(int index) {
  return op_arguments_.Mutable(index);
}
inline ::DModule_Expression* DModule_Expression::add_op_arguments() {
  return op_arguments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DModule_Expression >&
DModule_Expression::op_arguments() const {
  return op_arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::DModule_Expression >*
DModule_Expression::mutable_op_arguments() {
  return &op_arguments_;
}

// optional .DModule.TVar RdTmp_tval = 4;
inline bool DModule_Expression::has_rdtmp_tval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DModule_Expression::set_has_rdtmp_tval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DModule_Expression::clear_has_rdtmp_tval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DModule_Expression::clear_rdtmp_tval() {
  if (rdtmp_tval_ != NULL) rdtmp_tval_->::DModule_TVar::Clear();
  clear_has_rdtmp_tval();
}
inline const ::DModule_TVar& DModule_Expression::rdtmp_tval() const {
  return rdtmp_tval_ != NULL ? *rdtmp_tval_ : *default_instance_->rdtmp_tval_;
}
inline ::DModule_TVar* DModule_Expression::mutable_rdtmp_tval() {
  set_has_rdtmp_tval();
  if (rdtmp_tval_ == NULL) rdtmp_tval_ = new ::DModule_TVar;
  return rdtmp_tval_;
}
inline ::DModule_TVar* DModule_Expression::release_rdtmp_tval() {
  clear_has_rdtmp_tval();
  ::DModule_TVar* temp = rdtmp_tval_;
  rdtmp_tval_ = NULL;
  return temp;
}
inline void DModule_Expression::set_allocated_rdtmp_tval(::DModule_TVar* rdtmp_tval) {
  delete rdtmp_tval_;
  rdtmp_tval_ = rdtmp_tval;
  if (rdtmp_tval) {
    set_has_rdtmp_tval();
  } else {
    clear_has_rdtmp_tval();
  }
}

// optional .DModule.ValTy Load_loadTy = 5;
inline bool DModule_Expression::has_load_loadty() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DModule_Expression::set_has_load_loadty() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DModule_Expression::clear_has_load_loadty() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DModule_Expression::clear_load_loadty() {
  load_loadty_ = 0;
  clear_has_load_loadty();
}
inline ::DModule_ValTy DModule_Expression::load_loadty() const {
  return static_cast< ::DModule_ValTy >(load_loadty_);
}
inline void DModule_Expression::set_load_loadty(::DModule_ValTy value) {
  assert(::DModule_ValTy_IsValid(value));
  set_has_load_loadty();
  load_loadty_ = value;
}

// optional .DModule.Expression Load_addr = 6;
inline bool DModule_Expression::has_load_addr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DModule_Expression::set_has_load_addr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DModule_Expression::clear_has_load_addr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DModule_Expression::clear_load_addr() {
  if (load_addr_ != NULL) load_addr_->::DModule_Expression::Clear();
  clear_has_load_addr();
}
inline const ::DModule_Expression& DModule_Expression::load_addr() const {
  return load_addr_ != NULL ? *load_addr_ : *default_instance_->load_addr_;
}
inline ::DModule_Expression* DModule_Expression::mutable_load_addr() {
  set_has_load_addr();
  if (load_addr_ == NULL) load_addr_ = new ::DModule_Expression;
  return load_addr_;
}
inline ::DModule_Expression* DModule_Expression::release_load_addr() {
  clear_has_load_addr();
  ::DModule_Expression* temp = load_addr_;
  load_addr_ = NULL;
  return temp;
}
inline void DModule_Expression::set_allocated_load_addr(::DModule_Expression* load_addr) {
  delete load_addr_;
  load_addr_ = load_addr;
  if (load_addr) {
    set_has_load_addr();
  } else {
    clear_has_load_addr();
  }
}

// optional .DModule.Register Get_register = 7;
inline bool DModule_Expression::has_get_register() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DModule_Expression::set_has_get_register() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DModule_Expression::clear_has_get_register() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DModule_Expression::clear_get_register() {
  if (get_register_ != NULL) get_register_->::DModule_Register::Clear();
  clear_has_get_register();
}
inline const ::DModule_Register& DModule_Expression::get_register() const {
  return get_register_ != NULL ? *get_register_ : *default_instance_->get_register_;
}
inline ::DModule_Register* DModule_Expression::mutable_get_register() {
  set_has_get_register();
  if (get_register_ == NULL) get_register_ = new ::DModule_Register;
  return get_register_;
}
inline ::DModule_Register* DModule_Expression::release_get_register() {
  clear_has_get_register();
  ::DModule_Register* temp = get_register_;
  get_register_ = NULL;
  return temp;
}
inline void DModule_Expression::set_allocated_get_register(::DModule_Register* get_register) {
  delete get_register_;
  get_register_ = get_register;
  if (get_register) {
    set_has_get_register();
  } else {
    clear_has_get_register();
  }
}

// optional .DModule.ConstantValue Const_cval = 8;
inline bool DModule_Expression::has_const_cval() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DModule_Expression::set_has_const_cval() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DModule_Expression::clear_has_const_cval() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DModule_Expression::clear_const_cval() {
  if (const_cval_ != NULL) const_cval_->::DModule_ConstantValue::Clear();
  clear_has_const_cval();
}
inline const ::DModule_ConstantValue& DModule_Expression::const_cval() const {
  return const_cval_ != NULL ? *const_cval_ : *default_instance_->const_cval_;
}
inline ::DModule_ConstantValue* DModule_Expression::mutable_const_cval() {
  set_has_const_cval();
  if (const_cval_ == NULL) const_cval_ = new ::DModule_ConstantValue;
  return const_cval_;
}
inline ::DModule_ConstantValue* DModule_Expression::release_const_cval() {
  clear_has_const_cval();
  ::DModule_ConstantValue* temp = const_cval_;
  const_cval_ = NULL;
  return temp;
}
inline void DModule_Expression::set_allocated_const_cval(::DModule_ConstantValue* const_cval) {
  delete const_cval_;
  const_cval_ = const_cval;
  if (const_cval) {
    set_has_const_cval();
  } else {
    clear_has_const_cval();
  }
}

// optional .DModule.Expression Mux0X_condition = 9;
inline bool DModule_Expression::has_mux0x_condition() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DModule_Expression::set_has_mux0x_condition() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DModule_Expression::clear_has_mux0x_condition() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DModule_Expression::clear_mux0x_condition() {
  if (mux0x_condition_ != NULL) mux0x_condition_->::DModule_Expression::Clear();
  clear_has_mux0x_condition();
}
inline const ::DModule_Expression& DModule_Expression::mux0x_condition() const {
  return mux0x_condition_ != NULL ? *mux0x_condition_ : *default_instance_->mux0x_condition_;
}
inline ::DModule_Expression* DModule_Expression::mutable_mux0x_condition() {
  set_has_mux0x_condition();
  if (mux0x_condition_ == NULL) mux0x_condition_ = new ::DModule_Expression;
  return mux0x_condition_;
}
inline ::DModule_Expression* DModule_Expression::release_mux0x_condition() {
  clear_has_mux0x_condition();
  ::DModule_Expression* temp = mux0x_condition_;
  mux0x_condition_ = NULL;
  return temp;
}
inline void DModule_Expression::set_allocated_mux0x_condition(::DModule_Expression* mux0x_condition) {
  delete mux0x_condition_;
  mux0x_condition_ = mux0x_condition;
  if (mux0x_condition) {
    set_has_mux0x_condition();
  } else {
    clear_has_mux0x_condition();
  }
}

// optional .DModule.Expression Mux0X_iftrue = 10;
inline bool DModule_Expression::has_mux0x_iftrue() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DModule_Expression::set_has_mux0x_iftrue() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DModule_Expression::clear_has_mux0x_iftrue() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DModule_Expression::clear_mux0x_iftrue() {
  if (mux0x_iftrue_ != NULL) mux0x_iftrue_->::DModule_Expression::Clear();
  clear_has_mux0x_iftrue();
}
inline const ::DModule_Expression& DModule_Expression::mux0x_iftrue() const {
  return mux0x_iftrue_ != NULL ? *mux0x_iftrue_ : *default_instance_->mux0x_iftrue_;
}
inline ::DModule_Expression* DModule_Expression::mutable_mux0x_iftrue() {
  set_has_mux0x_iftrue();
  if (mux0x_iftrue_ == NULL) mux0x_iftrue_ = new ::DModule_Expression;
  return mux0x_iftrue_;
}
inline ::DModule_Expression* DModule_Expression::release_mux0x_iftrue() {
  clear_has_mux0x_iftrue();
  ::DModule_Expression* temp = mux0x_iftrue_;
  mux0x_iftrue_ = NULL;
  return temp;
}
inline void DModule_Expression::set_allocated_mux0x_iftrue(::DModule_Expression* mux0x_iftrue) {
  delete mux0x_iftrue_;
  mux0x_iftrue_ = mux0x_iftrue;
  if (mux0x_iftrue) {
    set_has_mux0x_iftrue();
  } else {
    clear_has_mux0x_iftrue();
  }
}

// optional .DModule.Expression Mux0X_iffalse = 11;
inline bool DModule_Expression::has_mux0x_iffalse() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DModule_Expression::set_has_mux0x_iffalse() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DModule_Expression::clear_has_mux0x_iffalse() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DModule_Expression::clear_mux0x_iffalse() {
  if (mux0x_iffalse_ != NULL) mux0x_iffalse_->::DModule_Expression::Clear();
  clear_has_mux0x_iffalse();
}
inline const ::DModule_Expression& DModule_Expression::mux0x_iffalse() const {
  return mux0x_iffalse_ != NULL ? *mux0x_iffalse_ : *default_instance_->mux0x_iffalse_;
}
inline ::DModule_Expression* DModule_Expression::mutable_mux0x_iffalse() {
  set_has_mux0x_iffalse();
  if (mux0x_iffalse_ == NULL) mux0x_iffalse_ = new ::DModule_Expression;
  return mux0x_iffalse_;
}
inline ::DModule_Expression* DModule_Expression::release_mux0x_iffalse() {
  clear_has_mux0x_iffalse();
  ::DModule_Expression* temp = mux0x_iffalse_;
  mux0x_iffalse_ = NULL;
  return temp;
}
inline void DModule_Expression::set_allocated_mux0x_iffalse(::DModule_Expression* mux0x_iffalse) {
  delete mux0x_iffalse_;
  mux0x_iffalse_ = mux0x_iffalse;
  if (mux0x_iffalse) {
    set_has_mux0x_iffalse();
  } else {
    clear_has_mux0x_iffalse();
  }
}

// optional .DModule.RegArray Get_regarray = 12;
inline bool DModule_Expression::has_get_regarray() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DModule_Expression::set_has_get_regarray() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DModule_Expression::clear_has_get_regarray() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DModule_Expression::clear_get_regarray() {
  if (get_regarray_ != NULL) get_regarray_->::DModule_RegArray::Clear();
  clear_has_get_regarray();
}
inline const ::DModule_RegArray& DModule_Expression::get_regarray() const {
  return get_regarray_ != NULL ? *get_regarray_ : *default_instance_->get_regarray_;
}
inline ::DModule_RegArray* DModule_Expression::mutable_get_regarray() {
  set_has_get_regarray();
  if (get_regarray_ == NULL) get_regarray_ = new ::DModule_RegArray;
  return get_regarray_;
}
inline ::DModule_RegArray* DModule_Expression::release_get_regarray() {
  clear_has_get_regarray();
  ::DModule_RegArray* temp = get_regarray_;
  get_regarray_ = NULL;
  return temp;
}
inline void DModule_Expression::set_allocated_get_regarray(::DModule_RegArray* get_regarray) {
  delete get_regarray_;
  get_regarray_ = get_regarray;
  if (get_regarray) {
    set_has_get_regarray();
  } else {
    clear_has_get_regarray();
  }
}

// optional string CCall_targetFunc = 13;
inline bool DModule_Expression::has_ccall_targetfunc() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DModule_Expression::set_has_ccall_targetfunc() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DModule_Expression::clear_has_ccall_targetfunc() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DModule_Expression::clear_ccall_targetfunc() {
  if (ccall_targetfunc_ != &::google::protobuf::internal::kEmptyString) {
    ccall_targetfunc_->clear();
  }
  clear_has_ccall_targetfunc();
}
inline const ::std::string& DModule_Expression::ccall_targetfunc() const {
  return *ccall_targetfunc_;
}
inline void DModule_Expression::set_ccall_targetfunc(const ::std::string& value) {
  set_has_ccall_targetfunc();
  if (ccall_targetfunc_ == &::google::protobuf::internal::kEmptyString) {
    ccall_targetfunc_ = new ::std::string;
  }
  ccall_targetfunc_->assign(value);
}
inline void DModule_Expression::set_ccall_targetfunc(const char* value) {
  set_has_ccall_targetfunc();
  if (ccall_targetfunc_ == &::google::protobuf::internal::kEmptyString) {
    ccall_targetfunc_ = new ::std::string;
  }
  ccall_targetfunc_->assign(value);
}
inline void DModule_Expression::set_ccall_targetfunc(const char* value, size_t size) {
  set_has_ccall_targetfunc();
  if (ccall_targetfunc_ == &::google::protobuf::internal::kEmptyString) {
    ccall_targetfunc_ = new ::std::string;
  }
  ccall_targetfunc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DModule_Expression::mutable_ccall_targetfunc() {
  set_has_ccall_targetfunc();
  if (ccall_targetfunc_ == &::google::protobuf::internal::kEmptyString) {
    ccall_targetfunc_ = new ::std::string;
  }
  return ccall_targetfunc_;
}
inline ::std::string* DModule_Expression::release_ccall_targetfunc() {
  clear_has_ccall_targetfunc();
  if (ccall_targetfunc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ccall_targetfunc_;
    ccall_targetfunc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DModule_Expression::set_allocated_ccall_targetfunc(::std::string* ccall_targetfunc) {
  if (ccall_targetfunc_ != &::google::protobuf::internal::kEmptyString) {
    delete ccall_targetfunc_;
  }
  if (ccall_targetfunc) {
    set_has_ccall_targetfunc();
    ccall_targetfunc_ = ccall_targetfunc;
  } else {
    clear_has_ccall_targetfunc();
    ccall_targetfunc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .DModule.Expression CCall_args = 14;
inline int DModule_Expression::ccall_args_size() const {
  return ccall_args_.size();
}
inline void DModule_Expression::clear_ccall_args() {
  ccall_args_.Clear();
}
inline const ::DModule_Expression& DModule_Expression::ccall_args(int index) const {
  return ccall_args_.Get(index);
}
inline ::DModule_Expression* DModule_Expression::mutable_ccall_args(int index) {
  return ccall_args_.Mutable(index);
}
inline ::DModule_Expression* DModule_Expression::add_ccall_args() {
  return ccall_args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DModule_Expression >&
DModule_Expression::ccall_args() const {
  return ccall_args_;
}
inline ::google::protobuf::RepeatedPtrField< ::DModule_Expression >*
DModule_Expression::mutable_ccall_args() {
  return &ccall_args_;
}

// optional .DModule.Expression Get_varpart = 15;
inline bool DModule_Expression::has_get_varpart() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DModule_Expression::set_has_get_varpart() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DModule_Expression::clear_has_get_varpart() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DModule_Expression::clear_get_varpart() {
  if (get_varpart_ != NULL) get_varpart_->::DModule_Expression::Clear();
  clear_has_get_varpart();
}
inline const ::DModule_Expression& DModule_Expression::get_varpart() const {
  return get_varpart_ != NULL ? *get_varpart_ : *default_instance_->get_varpart_;
}
inline ::DModule_Expression* DModule_Expression::mutable_get_varpart() {
  set_has_get_varpart();
  if (get_varpart_ == NULL) get_varpart_ = new ::DModule_Expression;
  return get_varpart_;
}
inline ::DModule_Expression* DModule_Expression::release_get_varpart() {
  clear_has_get_varpart();
  ::DModule_Expression* temp = get_varpart_;
  get_varpart_ = NULL;
  return temp;
}
inline void DModule_Expression::set_allocated_get_varpart(::DModule_Expression* get_varpart) {
  delete get_varpart_;
  get_varpart_ = get_varpart;
  if (get_varpart) {
    set_has_get_varpart();
  } else {
    clear_has_get_varpart();
  }
}

// optional int32 Get_bias = 16;
inline bool DModule_Expression::has_get_bias() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DModule_Expression::set_has_get_bias() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DModule_Expression::clear_has_get_bias() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DModule_Expression::clear_get_bias() {
  get_bias_ = 0;
  clear_has_get_bias();
}
inline ::google::protobuf::int32 DModule_Expression::get_bias() const {
  return get_bias_;
}
inline void DModule_Expression::set_get_bias(::google::protobuf::int32 value) {
  set_has_get_bias();
  get_bias_ = value;
}

// optional .DModule.TArch Get_arch = 17;
inline bool DModule_Expression::has_get_arch() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DModule_Expression::set_has_get_arch() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DModule_Expression::clear_has_get_arch() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DModule_Expression::clear_get_arch() {
  if (get_arch_ != NULL) get_arch_->::DModule_TArch::Clear();
  clear_has_get_arch();
}
inline const ::DModule_TArch& DModule_Expression::get_arch() const {
  return get_arch_ != NULL ? *get_arch_ : *default_instance_->get_arch_;
}
inline ::DModule_TArch* DModule_Expression::mutable_get_arch() {
  set_has_get_arch();
  if (get_arch_ == NULL) get_arch_ = new ::DModule_TArch;
  return get_arch_;
}
inline ::DModule_TArch* DModule_Expression::release_get_arch() {
  clear_has_get_arch();
  ::DModule_TArch* temp = get_arch_;
  get_arch_ = NULL;
  return temp;
}
inline void DModule_Expression::set_allocated_get_arch(::DModule_TArch* get_arch) {
  delete get_arch_;
  get_arch_ = get_arch;
  if (get_arch) {
    set_has_get_arch();
  } else {
    clear_has_get_arch();
  }
}

// optional int32 Get_offset = 18;
inline bool DModule_Expression::has_get_offset() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DModule_Expression::set_has_get_offset() {
  _has_bits_[0] |= 0x00020000u;
}
inline void DModule_Expression::clear_has_get_offset() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void DModule_Expression::clear_get_offset() {
  get_offset_ = 0;
  clear_has_get_offset();
}
inline ::google::protobuf::int32 DModule_Expression::get_offset() const {
  return get_offset_;
}
inline void DModule_Expression::set_get_offset(::google::protobuf::int32 value) {
  set_has_get_offset();
  get_offset_ = value;
}

// -------------------------------------------------------------------

// DModule_Register

// required .DModule.TArch arch = 1;
inline bool DModule_Register::has_arch() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DModule_Register::set_has_arch() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DModule_Register::clear_has_arch() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DModule_Register::clear_arch() {
  if (arch_ != NULL) arch_->::DModule_TArch::Clear();
  clear_has_arch();
}
inline const ::DModule_TArch& DModule_Register::arch() const {
  return arch_ != NULL ? *arch_ : *default_instance_->arch_;
}
inline ::DModule_TArch* DModule_Register::mutable_arch() {
  set_has_arch();
  if (arch_ == NULL) arch_ = new ::DModule_TArch;
  return arch_;
}
inline ::DModule_TArch* DModule_Register::release_arch() {
  clear_has_arch();
  ::DModule_TArch* temp = arch_;
  arch_ = NULL;
  return temp;
}
inline void DModule_Register::set_allocated_arch(::DModule_TArch* arch) {
  delete arch_;
  arch_ = arch;
  if (arch) {
    set_has_arch();
  } else {
    clear_has_arch();
  }
}

// optional .DModule.RegisterClass regClass = 2;
inline bool DModule_Register::has_regclass() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DModule_Register::set_has_regclass() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DModule_Register::clear_has_regclass() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DModule_Register::clear_regclass() {
  regclass_ = 0;
  clear_has_regclass();
}
inline ::DModule_RegisterClass DModule_Register::regclass() const {
  return static_cast< ::DModule_RegisterClass >(regclass_);
}
inline void DModule_Register::set_regclass(::DModule_RegisterClass value) {
  assert(::DModule_RegisterClass_IsValid(value));
  set_has_regclass();
  regclass_ = value;
}

// optional int32 width = 3;
inline bool DModule_Register::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DModule_Register::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DModule_Register::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DModule_Register::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 DModule_Register::width() const {
  return width_;
}
inline void DModule_Register::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// optional .DModule.x86reg_8 Reg8 = 4;
inline bool DModule_Register::has_reg8() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DModule_Register::set_has_reg8() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DModule_Register::clear_has_reg8() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DModule_Register::clear_reg8() {
  reg8_ = 0;
  clear_has_reg8();
}
inline ::DModule_x86reg_8 DModule_Register::reg8() const {
  return static_cast< ::DModule_x86reg_8 >(reg8_);
}
inline void DModule_Register::set_reg8(::DModule_x86reg_8 value) {
  assert(::DModule_x86reg_8_IsValid(value));
  set_has_reg8();
  reg8_ = value;
}

// optional .DModule.x86reg_16 Reg16 = 5;
inline bool DModule_Register::has_reg16() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DModule_Register::set_has_reg16() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DModule_Register::clear_has_reg16() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DModule_Register::clear_reg16() {
  reg16_ = 0;
  clear_has_reg16();
}
inline ::DModule_x86reg_16 DModule_Register::reg16() const {
  return static_cast< ::DModule_x86reg_16 >(reg16_);
}
inline void DModule_Register::set_reg16(::DModule_x86reg_16 value) {
  assert(::DModule_x86reg_16_IsValid(value));
  set_has_reg16();
  reg16_ = value;
}

// optional .DModule.x86reg_32 Reg32 = 6;
inline bool DModule_Register::has_reg32() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DModule_Register::set_has_reg32() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DModule_Register::clear_has_reg32() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DModule_Register::clear_reg32() {
  reg32_ = 0;
  clear_has_reg32();
}
inline ::DModule_x86reg_32 DModule_Register::reg32() const {
  return static_cast< ::DModule_x86reg_32 >(reg32_);
}
inline void DModule_Register::set_reg32(::DModule_x86reg_32 value) {
  assert(::DModule_x86reg_32_IsValid(value));
  set_has_reg32();
  reg32_ = value;
}

// optional .DModule.x86reg_64 Reg64 = 7;
inline bool DModule_Register::has_reg64() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DModule_Register::set_has_reg64() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DModule_Register::clear_has_reg64() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DModule_Register::clear_reg64() {
  reg64_ = 0;
  clear_has_reg64();
}
inline ::DModule_x86reg_64 DModule_Register::reg64() const {
  return static_cast< ::DModule_x86reg_64 >(reg64_);
}
inline void DModule_Register::set_reg64(::DModule_x86reg_64 value) {
  assert(::DModule_x86reg_64_IsValid(value));
  set_has_reg64();
  reg64_ = value;
}

// optional .DModule.armreg RegArm = 8;
inline bool DModule_Register::has_regarm() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DModule_Register::set_has_regarm() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DModule_Register::clear_has_regarm() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DModule_Register::clear_regarm() {
  regarm_ = 0;
  clear_has_regarm();
}
inline ::DModule_armreg DModule_Register::regarm() const {
  return static_cast< ::DModule_armreg >(regarm_);
}
inline void DModule_Register::set_regarm(::DModule_armreg value) {
  assert(::DModule_armreg_IsValid(value));
  set_has_regarm();
  regarm_ = value;
}

// -------------------------------------------------------------------

// DModule_Statement

// required .DModule.StType ty = 1;
inline bool DModule_Statement::has_ty() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DModule_Statement::set_has_ty() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DModule_Statement::clear_has_ty() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DModule_Statement::clear_ty() {
  ty_ = 0;
  clear_has_ty();
}
inline ::DModule_StType DModule_Statement::ty() const {
  return static_cast< ::DModule_StType >(ty_);
}
inline void DModule_Statement::set_ty(::DModule_StType value) {
  assert(::DModule_StType_IsValid(value));
  set_has_ty();
  ty_ = value;
}

// optional .DModule.Expression WrTmp_RHS = 2;
inline bool DModule_Statement::has_wrtmp_rhs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DModule_Statement::set_has_wrtmp_rhs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DModule_Statement::clear_has_wrtmp_rhs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DModule_Statement::clear_wrtmp_rhs() {
  if (wrtmp_rhs_ != NULL) wrtmp_rhs_->::DModule_Expression::Clear();
  clear_has_wrtmp_rhs();
}
inline const ::DModule_Expression& DModule_Statement::wrtmp_rhs() const {
  return wrtmp_rhs_ != NULL ? *wrtmp_rhs_ : *default_instance_->wrtmp_rhs_;
}
inline ::DModule_Expression* DModule_Statement::mutable_wrtmp_rhs() {
  set_has_wrtmp_rhs();
  if (wrtmp_rhs_ == NULL) wrtmp_rhs_ = new ::DModule_Expression;
  return wrtmp_rhs_;
}
inline ::DModule_Expression* DModule_Statement::release_wrtmp_rhs() {
  clear_has_wrtmp_rhs();
  ::DModule_Expression* temp = wrtmp_rhs_;
  wrtmp_rhs_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_wrtmp_rhs(::DModule_Expression* wrtmp_rhs) {
  delete wrtmp_rhs_;
  wrtmp_rhs_ = wrtmp_rhs;
  if (wrtmp_rhs) {
    set_has_wrtmp_rhs();
  } else {
    clear_has_wrtmp_rhs();
  }
}

// optional .DModule.TVar WrTmp_tmpWritten = 3;
inline bool DModule_Statement::has_wrtmp_tmpwritten() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DModule_Statement::set_has_wrtmp_tmpwritten() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DModule_Statement::clear_has_wrtmp_tmpwritten() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DModule_Statement::clear_wrtmp_tmpwritten() {
  if (wrtmp_tmpwritten_ != NULL) wrtmp_tmpwritten_->::DModule_TVar::Clear();
  clear_has_wrtmp_tmpwritten();
}
inline const ::DModule_TVar& DModule_Statement::wrtmp_tmpwritten() const {
  return wrtmp_tmpwritten_ != NULL ? *wrtmp_tmpwritten_ : *default_instance_->wrtmp_tmpwritten_;
}
inline ::DModule_TVar* DModule_Statement::mutable_wrtmp_tmpwritten() {
  set_has_wrtmp_tmpwritten();
  if (wrtmp_tmpwritten_ == NULL) wrtmp_tmpwritten_ = new ::DModule_TVar;
  return wrtmp_tmpwritten_;
}
inline ::DModule_TVar* DModule_Statement::release_wrtmp_tmpwritten() {
  clear_has_wrtmp_tmpwritten();
  ::DModule_TVar* temp = wrtmp_tmpwritten_;
  wrtmp_tmpwritten_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_wrtmp_tmpwritten(::DModule_TVar* wrtmp_tmpwritten) {
  delete wrtmp_tmpwritten_;
  wrtmp_tmpwritten_ = wrtmp_tmpwritten;
  if (wrtmp_tmpwritten) {
    set_has_wrtmp_tmpwritten();
  } else {
    clear_has_wrtmp_tmpwritten();
  }
}

// optional .DModule.Expression Put_data = 4;
inline bool DModule_Statement::has_put_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DModule_Statement::set_has_put_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DModule_Statement::clear_has_put_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DModule_Statement::clear_put_data() {
  if (put_data_ != NULL) put_data_->::DModule_Expression::Clear();
  clear_has_put_data();
}
inline const ::DModule_Expression& DModule_Statement::put_data() const {
  return put_data_ != NULL ? *put_data_ : *default_instance_->put_data_;
}
inline ::DModule_Expression* DModule_Statement::mutable_put_data() {
  set_has_put_data();
  if (put_data_ == NULL) put_data_ = new ::DModule_Expression;
  return put_data_;
}
inline ::DModule_Expression* DModule_Statement::release_put_data() {
  clear_has_put_data();
  ::DModule_Expression* temp = put_data_;
  put_data_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_put_data(::DModule_Expression* put_data) {
  delete put_data_;
  put_data_ = put_data;
  if (put_data) {
    set_has_put_data();
  } else {
    clear_has_put_data();
  }
}

// optional .DModule.Register Put_register = 5;
inline bool DModule_Statement::has_put_register() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DModule_Statement::set_has_put_register() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DModule_Statement::clear_has_put_register() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DModule_Statement::clear_put_register() {
  if (put_register_ != NULL) put_register_->::DModule_Register::Clear();
  clear_has_put_register();
}
inline const ::DModule_Register& DModule_Statement::put_register() const {
  return put_register_ != NULL ? *put_register_ : *default_instance_->put_register_;
}
inline ::DModule_Register* DModule_Statement::mutable_put_register() {
  set_has_put_register();
  if (put_register_ == NULL) put_register_ = new ::DModule_Register;
  return put_register_;
}
inline ::DModule_Register* DModule_Statement::release_put_register() {
  clear_has_put_register();
  ::DModule_Register* temp = put_register_;
  put_register_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_put_register(::DModule_Register* put_register) {
  delete put_register_;
  put_register_ = put_register;
  if (put_register) {
    set_has_put_register();
  } else {
    clear_has_put_register();
  }
}

// optional .DModule.Expression Store_data = 6;
inline bool DModule_Statement::has_store_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DModule_Statement::set_has_store_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DModule_Statement::clear_has_store_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DModule_Statement::clear_store_data() {
  if (store_data_ != NULL) store_data_->::DModule_Expression::Clear();
  clear_has_store_data();
}
inline const ::DModule_Expression& DModule_Statement::store_data() const {
  return store_data_ != NULL ? *store_data_ : *default_instance_->store_data_;
}
inline ::DModule_Expression* DModule_Statement::mutable_store_data() {
  set_has_store_data();
  if (store_data_ == NULL) store_data_ = new ::DModule_Expression;
  return store_data_;
}
inline ::DModule_Expression* DModule_Statement::release_store_data() {
  clear_has_store_data();
  ::DModule_Expression* temp = store_data_;
  store_data_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_store_data(::DModule_Expression* store_data) {
  delete store_data_;
  store_data_ = store_data;
  if (store_data) {
    set_has_store_data();
  } else {
    clear_has_store_data();
  }
}

// optional .DModule.Expression Store_addr = 7;
inline bool DModule_Statement::has_store_addr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DModule_Statement::set_has_store_addr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DModule_Statement::clear_has_store_addr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DModule_Statement::clear_store_addr() {
  if (store_addr_ != NULL) store_addr_->::DModule_Expression::Clear();
  clear_has_store_addr();
}
inline const ::DModule_Expression& DModule_Statement::store_addr() const {
  return store_addr_ != NULL ? *store_addr_ : *default_instance_->store_addr_;
}
inline ::DModule_Expression* DModule_Statement::mutable_store_addr() {
  set_has_store_addr();
  if (store_addr_ == NULL) store_addr_ = new ::DModule_Expression;
  return store_addr_;
}
inline ::DModule_Expression* DModule_Statement::release_store_addr() {
  clear_has_store_addr();
  ::DModule_Expression* temp = store_addr_;
  store_addr_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_store_addr(::DModule_Expression* store_addr) {
  delete store_addr_;
  store_addr_ = store_addr;
  if (store_addr) {
    set_has_store_addr();
  } else {
    clear_has_store_addr();
  }
}

// optional .DModule.ExitType Exit_blockexit = 8;
inline bool DModule_Statement::has_exit_blockexit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DModule_Statement::set_has_exit_blockexit() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DModule_Statement::clear_has_exit_blockexit() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DModule_Statement::clear_exit_blockexit() {
  exit_blockexit_ = 0;
  clear_has_exit_blockexit();
}
inline ::DModule_ExitType DModule_Statement::exit_blockexit() const {
  return static_cast< ::DModule_ExitType >(exit_blockexit_);
}
inline void DModule_Statement::set_exit_blockexit(::DModule_ExitType value) {
  assert(::DModule_ExitType_IsValid(value));
  set_has_exit_blockexit();
  exit_blockexit_ = value;
}

// optional .DModule.Expression Exit_guardExp = 9;
inline bool DModule_Statement::has_exit_guardexp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DModule_Statement::set_has_exit_guardexp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DModule_Statement::clear_has_exit_guardexp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DModule_Statement::clear_exit_guardexp() {
  if (exit_guardexp_ != NULL) exit_guardexp_->::DModule_Expression::Clear();
  clear_has_exit_guardexp();
}
inline const ::DModule_Expression& DModule_Statement::exit_guardexp() const {
  return exit_guardexp_ != NULL ? *exit_guardexp_ : *default_instance_->exit_guardexp_;
}
inline ::DModule_Expression* DModule_Statement::mutable_exit_guardexp() {
  set_has_exit_guardexp();
  if (exit_guardexp_ == NULL) exit_guardexp_ = new ::DModule_Expression;
  return exit_guardexp_;
}
inline ::DModule_Expression* DModule_Statement::release_exit_guardexp() {
  clear_has_exit_guardexp();
  ::DModule_Expression* temp = exit_guardexp_;
  exit_guardexp_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_exit_guardexp(::DModule_Expression* exit_guardexp) {
  delete exit_guardexp_;
  exit_guardexp_ = exit_guardexp;
  if (exit_guardexp) {
    set_has_exit_guardexp();
  } else {
    clear_has_exit_guardexp();
  }
}

// optional .DModule.Expression Exit_jmpTarget = 10;
inline bool DModule_Statement::has_exit_jmptarget() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DModule_Statement::set_has_exit_jmptarget() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DModule_Statement::clear_has_exit_jmptarget() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DModule_Statement::clear_exit_jmptarget() {
  if (exit_jmptarget_ != NULL) exit_jmptarget_->::DModule_Expression::Clear();
  clear_has_exit_jmptarget();
}
inline const ::DModule_Expression& DModule_Statement::exit_jmptarget() const {
  return exit_jmptarget_ != NULL ? *exit_jmptarget_ : *default_instance_->exit_jmptarget_;
}
inline ::DModule_Expression* DModule_Statement::mutable_exit_jmptarget() {
  set_has_exit_jmptarget();
  if (exit_jmptarget_ == NULL) exit_jmptarget_ = new ::DModule_Expression;
  return exit_jmptarget_;
}
inline ::DModule_Expression* DModule_Statement::release_exit_jmptarget() {
  clear_has_exit_jmptarget();
  ::DModule_Expression* temp = exit_jmptarget_;
  exit_jmptarget_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_exit_jmptarget(::DModule_Expression* exit_jmptarget) {
  delete exit_jmptarget_;
  exit_jmptarget_ = exit_jmptarget;
  if (exit_jmptarget) {
    set_has_exit_jmptarget();
  } else {
    clear_has_exit_jmptarget();
  }
}

// optional .DModule.Expression LLSC_addr = 11;
inline bool DModule_Statement::has_llsc_addr() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DModule_Statement::set_has_llsc_addr() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DModule_Statement::clear_has_llsc_addr() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DModule_Statement::clear_llsc_addr() {
  if (llsc_addr_ != NULL) llsc_addr_->::DModule_Expression::Clear();
  clear_has_llsc_addr();
}
inline const ::DModule_Expression& DModule_Statement::llsc_addr() const {
  return llsc_addr_ != NULL ? *llsc_addr_ : *default_instance_->llsc_addr_;
}
inline ::DModule_Expression* DModule_Statement::mutable_llsc_addr() {
  set_has_llsc_addr();
  if (llsc_addr_ == NULL) llsc_addr_ = new ::DModule_Expression;
  return llsc_addr_;
}
inline ::DModule_Expression* DModule_Statement::release_llsc_addr() {
  clear_has_llsc_addr();
  ::DModule_Expression* temp = llsc_addr_;
  llsc_addr_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_llsc_addr(::DModule_Expression* llsc_addr) {
  delete llsc_addr_;
  llsc_addr_ = llsc_addr;
  if (llsc_addr) {
    set_has_llsc_addr();
  } else {
    clear_has_llsc_addr();
  }
}

// optional .DModule.Expression LLSC_storedata = 12;
inline bool DModule_Statement::has_llsc_storedata() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DModule_Statement::set_has_llsc_storedata() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DModule_Statement::clear_has_llsc_storedata() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DModule_Statement::clear_llsc_storedata() {
  if (llsc_storedata_ != NULL) llsc_storedata_->::DModule_Expression::Clear();
  clear_has_llsc_storedata();
}
inline const ::DModule_Expression& DModule_Statement::llsc_storedata() const {
  return llsc_storedata_ != NULL ? *llsc_storedata_ : *default_instance_->llsc_storedata_;
}
inline ::DModule_Expression* DModule_Statement::mutable_llsc_storedata() {
  set_has_llsc_storedata();
  if (llsc_storedata_ == NULL) llsc_storedata_ = new ::DModule_Expression;
  return llsc_storedata_;
}
inline ::DModule_Expression* DModule_Statement::release_llsc_storedata() {
  clear_has_llsc_storedata();
  ::DModule_Expression* temp = llsc_storedata_;
  llsc_storedata_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_llsc_storedata(::DModule_Expression* llsc_storedata) {
  delete llsc_storedata_;
  llsc_storedata_ = llsc_storedata;
  if (llsc_storedata) {
    set_has_llsc_storedata();
  } else {
    clear_has_llsc_storedata();
  }
}

// optional .DModule.TVar LLSC_result = 13;
inline bool DModule_Statement::has_llsc_result() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DModule_Statement::set_has_llsc_result() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DModule_Statement::clear_has_llsc_result() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DModule_Statement::clear_llsc_result() {
  if (llsc_result_ != NULL) llsc_result_->::DModule_TVar::Clear();
  clear_has_llsc_result();
}
inline const ::DModule_TVar& DModule_Statement::llsc_result() const {
  return llsc_result_ != NULL ? *llsc_result_ : *default_instance_->llsc_result_;
}
inline ::DModule_TVar* DModule_Statement::mutable_llsc_result() {
  set_has_llsc_result();
  if (llsc_result_ == NULL) llsc_result_ = new ::DModule_TVar;
  return llsc_result_;
}
inline ::DModule_TVar* DModule_Statement::release_llsc_result() {
  clear_has_llsc_result();
  ::DModule_TVar* temp = llsc_result_;
  llsc_result_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_llsc_result(::DModule_TVar* llsc_result) {
  delete llsc_result_;
  llsc_result_ = llsc_result;
  if (llsc_result) {
    set_has_llsc_result();
  } else {
    clear_has_llsc_result();
  }
}

// optional .DModule.Expression Dirty_addr = 14;
inline bool DModule_Statement::has_dirty_addr() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DModule_Statement::set_has_dirty_addr() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DModule_Statement::clear_has_dirty_addr() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DModule_Statement::clear_dirty_addr() {
  if (dirty_addr_ != NULL) dirty_addr_->::DModule_Expression::Clear();
  clear_has_dirty_addr();
}
inline const ::DModule_Expression& DModule_Statement::dirty_addr() const {
  return dirty_addr_ != NULL ? *dirty_addr_ : *default_instance_->dirty_addr_;
}
inline ::DModule_Expression* DModule_Statement::mutable_dirty_addr() {
  set_has_dirty_addr();
  if (dirty_addr_ == NULL) dirty_addr_ = new ::DModule_Expression;
  return dirty_addr_;
}
inline ::DModule_Expression* DModule_Statement::release_dirty_addr() {
  clear_has_dirty_addr();
  ::DModule_Expression* temp = dirty_addr_;
  dirty_addr_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_dirty_addr(::DModule_Expression* dirty_addr) {
  delete dirty_addr_;
  dirty_addr_ = dirty_addr;
  if (dirty_addr) {
    set_has_dirty_addr();
  } else {
    clear_has_dirty_addr();
  }
}

// optional .DModule.Expression Dirty_guard = 15;
inline bool DModule_Statement::has_dirty_guard() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DModule_Statement::set_has_dirty_guard() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DModule_Statement::clear_has_dirty_guard() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DModule_Statement::clear_dirty_guard() {
  if (dirty_guard_ != NULL) dirty_guard_->::DModule_Expression::Clear();
  clear_has_dirty_guard();
}
inline const ::DModule_Expression& DModule_Statement::dirty_guard() const {
  return dirty_guard_ != NULL ? *dirty_guard_ : *default_instance_->dirty_guard_;
}
inline ::DModule_Expression* DModule_Statement::mutable_dirty_guard() {
  set_has_dirty_guard();
  if (dirty_guard_ == NULL) dirty_guard_ = new ::DModule_Expression;
  return dirty_guard_;
}
inline ::DModule_Expression* DModule_Statement::release_dirty_guard() {
  clear_has_dirty_guard();
  ::DModule_Expression* temp = dirty_guard_;
  dirty_guard_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_dirty_guard(::DModule_Expression* dirty_guard) {
  delete dirty_guard_;
  dirty_guard_ = dirty_guard;
  if (dirty_guard) {
    set_has_dirty_guard();
  } else {
    clear_has_dirty_guard();
  }
}

// repeated .DModule.Expression Dirty_args = 16;
inline int DModule_Statement::dirty_args_size() const {
  return dirty_args_.size();
}
inline void DModule_Statement::clear_dirty_args() {
  dirty_args_.Clear();
}
inline const ::DModule_Expression& DModule_Statement::dirty_args(int index) const {
  return dirty_args_.Get(index);
}
inline ::DModule_Expression* DModule_Statement::mutable_dirty_args(int index) {
  return dirty_args_.Mutable(index);
}
inline ::DModule_Expression* DModule_Statement::add_dirty_args() {
  return dirty_args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DModule_Expression >&
DModule_Statement::dirty_args() const {
  return dirty_args_;
}
inline ::google::protobuf::RepeatedPtrField< ::DModule_Expression >*
DModule_Statement::mutable_dirty_args() {
  return &dirty_args_;
}

// optional string Dirty_calleename = 17;
inline bool DModule_Statement::has_dirty_calleename() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DModule_Statement::set_has_dirty_calleename() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DModule_Statement::clear_has_dirty_calleename() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DModule_Statement::clear_dirty_calleename() {
  if (dirty_calleename_ != &::google::protobuf::internal::kEmptyString) {
    dirty_calleename_->clear();
  }
  clear_has_dirty_calleename();
}
inline const ::std::string& DModule_Statement::dirty_calleename() const {
  return *dirty_calleename_;
}
inline void DModule_Statement::set_dirty_calleename(const ::std::string& value) {
  set_has_dirty_calleename();
  if (dirty_calleename_ == &::google::protobuf::internal::kEmptyString) {
    dirty_calleename_ = new ::std::string;
  }
  dirty_calleename_->assign(value);
}
inline void DModule_Statement::set_dirty_calleename(const char* value) {
  set_has_dirty_calleename();
  if (dirty_calleename_ == &::google::protobuf::internal::kEmptyString) {
    dirty_calleename_ = new ::std::string;
  }
  dirty_calleename_->assign(value);
}
inline void DModule_Statement::set_dirty_calleename(const char* value, size_t size) {
  set_has_dirty_calleename();
  if (dirty_calleename_ == &::google::protobuf::internal::kEmptyString) {
    dirty_calleename_ = new ::std::string;
  }
  dirty_calleename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DModule_Statement::mutable_dirty_calleename() {
  set_has_dirty_calleename();
  if (dirty_calleename_ == &::google::protobuf::internal::kEmptyString) {
    dirty_calleename_ = new ::std::string;
  }
  return dirty_calleename_;
}
inline ::std::string* DModule_Statement::release_dirty_calleename() {
  clear_has_dirty_calleename();
  if (dirty_calleename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dirty_calleename_;
    dirty_calleename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DModule_Statement::set_allocated_dirty_calleename(::std::string* dirty_calleename) {
  if (dirty_calleename_ != &::google::protobuf::internal::kEmptyString) {
    delete dirty_calleename_;
  }
  if (dirty_calleename) {
    set_has_dirty_calleename();
    dirty_calleename_ = dirty_calleename;
  } else {
    clear_has_dirty_calleename();
    dirty_calleename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .DModule.TVar Dirty_tmp = 18;
inline bool DModule_Statement::has_dirty_tmp() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DModule_Statement::set_has_dirty_tmp() {
  _has_bits_[0] |= 0x00020000u;
}
inline void DModule_Statement::clear_has_dirty_tmp() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void DModule_Statement::clear_dirty_tmp() {
  if (dirty_tmp_ != NULL) dirty_tmp_->::DModule_TVar::Clear();
  clear_has_dirty_tmp();
}
inline const ::DModule_TVar& DModule_Statement::dirty_tmp() const {
  return dirty_tmp_ != NULL ? *dirty_tmp_ : *default_instance_->dirty_tmp_;
}
inline ::DModule_TVar* DModule_Statement::mutable_dirty_tmp() {
  set_has_dirty_tmp();
  if (dirty_tmp_ == NULL) dirty_tmp_ = new ::DModule_TVar;
  return dirty_tmp_;
}
inline ::DModule_TVar* DModule_Statement::release_dirty_tmp() {
  clear_has_dirty_tmp();
  ::DModule_TVar* temp = dirty_tmp_;
  dirty_tmp_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_dirty_tmp(::DModule_TVar* dirty_tmp) {
  delete dirty_tmp_;
  dirty_tmp_ = dirty_tmp;
  if (dirty_tmp) {
    set_has_dirty_tmp();
  } else {
    clear_has_dirty_tmp();
  }
}

// optional .DModule.Expression CAS_storeAddr = 19;
inline bool DModule_Statement::has_cas_storeaddr() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void DModule_Statement::set_has_cas_storeaddr() {
  _has_bits_[0] |= 0x00040000u;
}
inline void DModule_Statement::clear_has_cas_storeaddr() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void DModule_Statement::clear_cas_storeaddr() {
  if (cas_storeaddr_ != NULL) cas_storeaddr_->::DModule_Expression::Clear();
  clear_has_cas_storeaddr();
}
inline const ::DModule_Expression& DModule_Statement::cas_storeaddr() const {
  return cas_storeaddr_ != NULL ? *cas_storeaddr_ : *default_instance_->cas_storeaddr_;
}
inline ::DModule_Expression* DModule_Statement::mutable_cas_storeaddr() {
  set_has_cas_storeaddr();
  if (cas_storeaddr_ == NULL) cas_storeaddr_ = new ::DModule_Expression;
  return cas_storeaddr_;
}
inline ::DModule_Expression* DModule_Statement::release_cas_storeaddr() {
  clear_has_cas_storeaddr();
  ::DModule_Expression* temp = cas_storeaddr_;
  cas_storeaddr_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_cas_storeaddr(::DModule_Expression* cas_storeaddr) {
  delete cas_storeaddr_;
  cas_storeaddr_ = cas_storeaddr;
  if (cas_storeaddr) {
    set_has_cas_storeaddr();
  } else {
    clear_has_cas_storeaddr();
  }
}

// optional .DModule.Expression CAS_datahi = 20;
inline bool DModule_Statement::has_cas_datahi() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void DModule_Statement::set_has_cas_datahi() {
  _has_bits_[0] |= 0x00080000u;
}
inline void DModule_Statement::clear_has_cas_datahi() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void DModule_Statement::clear_cas_datahi() {
  if (cas_datahi_ != NULL) cas_datahi_->::DModule_Expression::Clear();
  clear_has_cas_datahi();
}
inline const ::DModule_Expression& DModule_Statement::cas_datahi() const {
  return cas_datahi_ != NULL ? *cas_datahi_ : *default_instance_->cas_datahi_;
}
inline ::DModule_Expression* DModule_Statement::mutable_cas_datahi() {
  set_has_cas_datahi();
  if (cas_datahi_ == NULL) cas_datahi_ = new ::DModule_Expression;
  return cas_datahi_;
}
inline ::DModule_Expression* DModule_Statement::release_cas_datahi() {
  clear_has_cas_datahi();
  ::DModule_Expression* temp = cas_datahi_;
  cas_datahi_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_cas_datahi(::DModule_Expression* cas_datahi) {
  delete cas_datahi_;
  cas_datahi_ = cas_datahi;
  if (cas_datahi) {
    set_has_cas_datahi();
  } else {
    clear_has_cas_datahi();
  }
}

// optional .DModule.Expression CAS_datalo = 21;
inline bool DModule_Statement::has_cas_datalo() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void DModule_Statement::set_has_cas_datalo() {
  _has_bits_[0] |= 0x00100000u;
}
inline void DModule_Statement::clear_has_cas_datalo() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void DModule_Statement::clear_cas_datalo() {
  if (cas_datalo_ != NULL) cas_datalo_->::DModule_Expression::Clear();
  clear_has_cas_datalo();
}
inline const ::DModule_Expression& DModule_Statement::cas_datalo() const {
  return cas_datalo_ != NULL ? *cas_datalo_ : *default_instance_->cas_datalo_;
}
inline ::DModule_Expression* DModule_Statement::mutable_cas_datalo() {
  set_has_cas_datalo();
  if (cas_datalo_ == NULL) cas_datalo_ = new ::DModule_Expression;
  return cas_datalo_;
}
inline ::DModule_Expression* DModule_Statement::release_cas_datalo() {
  clear_has_cas_datalo();
  ::DModule_Expression* temp = cas_datalo_;
  cas_datalo_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_cas_datalo(::DModule_Expression* cas_datalo) {
  delete cas_datalo_;
  cas_datalo_ = cas_datalo;
  if (cas_datalo) {
    set_has_cas_datalo();
  } else {
    clear_has_cas_datalo();
  }
}

// optional .DModule.Expression CAS_expectedhi = 22;
inline bool DModule_Statement::has_cas_expectedhi() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void DModule_Statement::set_has_cas_expectedhi() {
  _has_bits_[0] |= 0x00200000u;
}
inline void DModule_Statement::clear_has_cas_expectedhi() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void DModule_Statement::clear_cas_expectedhi() {
  if (cas_expectedhi_ != NULL) cas_expectedhi_->::DModule_Expression::Clear();
  clear_has_cas_expectedhi();
}
inline const ::DModule_Expression& DModule_Statement::cas_expectedhi() const {
  return cas_expectedhi_ != NULL ? *cas_expectedhi_ : *default_instance_->cas_expectedhi_;
}
inline ::DModule_Expression* DModule_Statement::mutable_cas_expectedhi() {
  set_has_cas_expectedhi();
  if (cas_expectedhi_ == NULL) cas_expectedhi_ = new ::DModule_Expression;
  return cas_expectedhi_;
}
inline ::DModule_Expression* DModule_Statement::release_cas_expectedhi() {
  clear_has_cas_expectedhi();
  ::DModule_Expression* temp = cas_expectedhi_;
  cas_expectedhi_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_cas_expectedhi(::DModule_Expression* cas_expectedhi) {
  delete cas_expectedhi_;
  cas_expectedhi_ = cas_expectedhi;
  if (cas_expectedhi) {
    set_has_cas_expectedhi();
  } else {
    clear_has_cas_expectedhi();
  }
}

// optional .DModule.Expression CAS_expectedlo = 23;
inline bool DModule_Statement::has_cas_expectedlo() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void DModule_Statement::set_has_cas_expectedlo() {
  _has_bits_[0] |= 0x00400000u;
}
inline void DModule_Statement::clear_has_cas_expectedlo() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void DModule_Statement::clear_cas_expectedlo() {
  if (cas_expectedlo_ != NULL) cas_expectedlo_->::DModule_Expression::Clear();
  clear_has_cas_expectedlo();
}
inline const ::DModule_Expression& DModule_Statement::cas_expectedlo() const {
  return cas_expectedlo_ != NULL ? *cas_expectedlo_ : *default_instance_->cas_expectedlo_;
}
inline ::DModule_Expression* DModule_Statement::mutable_cas_expectedlo() {
  set_has_cas_expectedlo();
  if (cas_expectedlo_ == NULL) cas_expectedlo_ = new ::DModule_Expression;
  return cas_expectedlo_;
}
inline ::DModule_Expression* DModule_Statement::release_cas_expectedlo() {
  clear_has_cas_expectedlo();
  ::DModule_Expression* temp = cas_expectedlo_;
  cas_expectedlo_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_cas_expectedlo(::DModule_Expression* cas_expectedlo) {
  delete cas_expectedlo_;
  cas_expectedlo_ = cas_expectedlo;
  if (cas_expectedlo) {
    set_has_cas_expectedlo();
  } else {
    clear_has_cas_expectedlo();
  }
}

// optional .DModule.TVar CAS_oldhi = 24;
inline bool DModule_Statement::has_cas_oldhi() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void DModule_Statement::set_has_cas_oldhi() {
  _has_bits_[0] |= 0x00800000u;
}
inline void DModule_Statement::clear_has_cas_oldhi() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void DModule_Statement::clear_cas_oldhi() {
  if (cas_oldhi_ != NULL) cas_oldhi_->::DModule_TVar::Clear();
  clear_has_cas_oldhi();
}
inline const ::DModule_TVar& DModule_Statement::cas_oldhi() const {
  return cas_oldhi_ != NULL ? *cas_oldhi_ : *default_instance_->cas_oldhi_;
}
inline ::DModule_TVar* DModule_Statement::mutable_cas_oldhi() {
  set_has_cas_oldhi();
  if (cas_oldhi_ == NULL) cas_oldhi_ = new ::DModule_TVar;
  return cas_oldhi_;
}
inline ::DModule_TVar* DModule_Statement::release_cas_oldhi() {
  clear_has_cas_oldhi();
  ::DModule_TVar* temp = cas_oldhi_;
  cas_oldhi_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_cas_oldhi(::DModule_TVar* cas_oldhi) {
  delete cas_oldhi_;
  cas_oldhi_ = cas_oldhi;
  if (cas_oldhi) {
    set_has_cas_oldhi();
  } else {
    clear_has_cas_oldhi();
  }
}

// optional .DModule.TVar CAS_oldlo = 25;
inline bool DModule_Statement::has_cas_oldlo() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void DModule_Statement::set_has_cas_oldlo() {
  _has_bits_[0] |= 0x01000000u;
}
inline void DModule_Statement::clear_has_cas_oldlo() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void DModule_Statement::clear_cas_oldlo() {
  if (cas_oldlo_ != NULL) cas_oldlo_->::DModule_TVar::Clear();
  clear_has_cas_oldlo();
}
inline const ::DModule_TVar& DModule_Statement::cas_oldlo() const {
  return cas_oldlo_ != NULL ? *cas_oldlo_ : *default_instance_->cas_oldlo_;
}
inline ::DModule_TVar* DModule_Statement::mutable_cas_oldlo() {
  set_has_cas_oldlo();
  if (cas_oldlo_ == NULL) cas_oldlo_ = new ::DModule_TVar;
  return cas_oldlo_;
}
inline ::DModule_TVar* DModule_Statement::release_cas_oldlo() {
  clear_has_cas_oldlo();
  ::DModule_TVar* temp = cas_oldlo_;
  cas_oldlo_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_cas_oldlo(::DModule_TVar* cas_oldlo) {
  delete cas_oldlo_;
  cas_oldlo_ = cas_oldlo;
  if (cas_oldlo) {
    set_has_cas_oldlo();
  } else {
    clear_has_cas_oldlo();
  }
}

// optional .DModule.MemoryEnd CAS_end = 26;
inline bool DModule_Statement::has_cas_end() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void DModule_Statement::set_has_cas_end() {
  _has_bits_[0] |= 0x02000000u;
}
inline void DModule_Statement::clear_has_cas_end() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void DModule_Statement::clear_cas_end() {
  cas_end_ = 0;
  clear_has_cas_end();
}
inline ::DModule_MemoryEnd DModule_Statement::cas_end() const {
  return static_cast< ::DModule_MemoryEnd >(cas_end_);
}
inline void DModule_Statement::set_cas_end(::DModule_MemoryEnd value) {
  assert(::DModule_MemoryEnd_IsValid(value));
  set_has_cas_end();
  cas_end_ = value;
}

// optional .DModule.MemoryEnd LLSC_end = 27;
inline bool DModule_Statement::has_llsc_end() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void DModule_Statement::set_has_llsc_end() {
  _has_bits_[0] |= 0x04000000u;
}
inline void DModule_Statement::clear_has_llsc_end() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void DModule_Statement::clear_llsc_end() {
  llsc_end_ = 0;
  clear_has_llsc_end();
}
inline ::DModule_MemoryEnd DModule_Statement::llsc_end() const {
  return static_cast< ::DModule_MemoryEnd >(llsc_end_);
}
inline void DModule_Statement::set_llsc_end(::DModule_MemoryEnd value) {
  assert(::DModule_MemoryEnd_IsValid(value));
  set_has_llsc_end();
  llsc_end_ = value;
}

// optional .DModule.RegArray Put_regarray = 28;
inline bool DModule_Statement::has_put_regarray() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void DModule_Statement::set_has_put_regarray() {
  _has_bits_[0] |= 0x08000000u;
}
inline void DModule_Statement::clear_has_put_regarray() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void DModule_Statement::clear_put_regarray() {
  if (put_regarray_ != NULL) put_regarray_->::DModule_RegArray::Clear();
  clear_has_put_regarray();
}
inline const ::DModule_RegArray& DModule_Statement::put_regarray() const {
  return put_regarray_ != NULL ? *put_regarray_ : *default_instance_->put_regarray_;
}
inline ::DModule_RegArray* DModule_Statement::mutable_put_regarray() {
  set_has_put_regarray();
  if (put_regarray_ == NULL) put_regarray_ = new ::DModule_RegArray;
  return put_regarray_;
}
inline ::DModule_RegArray* DModule_Statement::release_put_regarray() {
  clear_has_put_regarray();
  ::DModule_RegArray* temp = put_regarray_;
  put_regarray_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_put_regarray(::DModule_RegArray* put_regarray) {
  delete put_regarray_;
  put_regarray_ = put_regarray;
  if (put_regarray) {
    set_has_put_regarray();
  } else {
    clear_has_put_regarray();
  }
}

// optional int32 Put_bias = 29;
inline bool DModule_Statement::has_put_bias() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void DModule_Statement::set_has_put_bias() {
  _has_bits_[0] |= 0x10000000u;
}
inline void DModule_Statement::clear_has_put_bias() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void DModule_Statement::clear_put_bias() {
  put_bias_ = 0;
  clear_has_put_bias();
}
inline ::google::protobuf::int32 DModule_Statement::put_bias() const {
  return put_bias_;
}
inline void DModule_Statement::set_put_bias(::google::protobuf::int32 value) {
  set_has_put_bias();
  put_bias_ = value;
}

// optional .DModule.Expression Put_varpart = 30;
inline bool DModule_Statement::has_put_varpart() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void DModule_Statement::set_has_put_varpart() {
  _has_bits_[0] |= 0x20000000u;
}
inline void DModule_Statement::clear_has_put_varpart() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void DModule_Statement::clear_put_varpart() {
  if (put_varpart_ != NULL) put_varpart_->::DModule_Expression::Clear();
  clear_has_put_varpart();
}
inline const ::DModule_Expression& DModule_Statement::put_varpart() const {
  return put_varpart_ != NULL ? *put_varpart_ : *default_instance_->put_varpart_;
}
inline ::DModule_Expression* DModule_Statement::mutable_put_varpart() {
  set_has_put_varpart();
  if (put_varpart_ == NULL) put_varpart_ = new ::DModule_Expression;
  return put_varpart_;
}
inline ::DModule_Expression* DModule_Statement::release_put_varpart() {
  clear_has_put_varpart();
  ::DModule_Expression* temp = put_varpart_;
  put_varpart_ = NULL;
  return temp;
}
inline void DModule_Statement::set_allocated_put_varpart(::DModule_Expression* put_varpart) {
  delete put_varpart_;
  put_varpart_ = put_varpart;
  if (put_varpart) {
    set_has_put_varpart();
  } else {
    clear_has_put_varpart();
  }
}

// -------------------------------------------------------------------

// DModule_DBlock

// required int64 baseAddr = 1;
inline bool DModule_DBlock::has_baseaddr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DModule_DBlock::set_has_baseaddr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DModule_DBlock::clear_has_baseaddr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DModule_DBlock::clear_baseaddr() {
  baseaddr_ = GOOGLE_LONGLONG(0);
  clear_has_baseaddr();
}
inline ::google::protobuf::int64 DModule_DBlock::baseaddr() const {
  return baseaddr_;
}
inline void DModule_DBlock::set_baseaddr(::google::protobuf::int64 value) {
  set_has_baseaddr();
  baseaddr_ = value;
}

// repeated .DModule.TVar temps = 2;
inline int DModule_DBlock::temps_size() const {
  return temps_.size();
}
inline void DModule_DBlock::clear_temps() {
  temps_.Clear();
}
inline const ::DModule_TVar& DModule_DBlock::temps(int index) const {
  return temps_.Get(index);
}
inline ::DModule_TVar* DModule_DBlock::mutable_temps(int index) {
  return temps_.Mutable(index);
}
inline ::DModule_TVar* DModule_DBlock::add_temps() {
  return temps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DModule_TVar >&
DModule_DBlock::temps() const {
  return temps_;
}
inline ::google::protobuf::RepeatedPtrField< ::DModule_TVar >*
DModule_DBlock::mutable_temps() {
  return &temps_;
}

// required .DModule.TArch arch = 3;
inline bool DModule_DBlock::has_arch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DModule_DBlock::set_has_arch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DModule_DBlock::clear_has_arch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DModule_DBlock::clear_arch() {
  if (arch_ != NULL) arch_->::DModule_TArch::Clear();
  clear_has_arch();
}
inline const ::DModule_TArch& DModule_DBlock::arch() const {
  return arch_ != NULL ? *arch_ : *default_instance_->arch_;
}
inline ::DModule_TArch* DModule_DBlock::mutable_arch() {
  set_has_arch();
  if (arch_ == NULL) arch_ = new ::DModule_TArch;
  return arch_;
}
inline ::DModule_TArch* DModule_DBlock::release_arch() {
  clear_has_arch();
  ::DModule_TArch* temp = arch_;
  arch_ = NULL;
  return temp;
}
inline void DModule_DBlock::set_allocated_arch(::DModule_TArch* arch) {
  delete arch_;
  arch_ = arch;
  if (arch) {
    set_has_arch();
  } else {
    clear_has_arch();
  }
}

// required int32 len = 4;
inline bool DModule_DBlock::has_len() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DModule_DBlock::set_has_len() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DModule_DBlock::clear_has_len() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DModule_DBlock::clear_len() {
  len_ = 0;
  clear_has_len();
}
inline ::google::protobuf::int32 DModule_DBlock::len() const {
  return len_;
}
inline void DModule_DBlock::set_len(::google::protobuf::int32 value) {
  set_has_len();
  len_ = value;
}

// repeated .DModule.Statement stmts = 5;
inline int DModule_DBlock::stmts_size() const {
  return stmts_.size();
}
inline void DModule_DBlock::clear_stmts() {
  stmts_.Clear();
}
inline const ::DModule_Statement& DModule_DBlock::stmts(int index) const {
  return stmts_.Get(index);
}
inline ::DModule_Statement* DModule_DBlock::mutable_stmts(int index) {
  return stmts_.Mutable(index);
}
inline ::DModule_Statement* DModule_DBlock::add_stmts() {
  return stmts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DModule_Statement >&
DModule_DBlock::stmts() const {
  return stmts_;
}
inline ::google::protobuf::RepeatedPtrField< ::DModule_Statement >*
DModule_DBlock::mutable_stmts() {
  return &stmts_;
}

// required .DModule.Expression next = 6;
inline bool DModule_DBlock::has_next() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DModule_DBlock::set_has_next() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DModule_DBlock::clear_has_next() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DModule_DBlock::clear_next() {
  if (next_ != NULL) next_->::DModule_Expression::Clear();
  clear_has_next();
}
inline const ::DModule_Expression& DModule_DBlock::next() const {
  return next_ != NULL ? *next_ : *default_instance_->next_;
}
inline ::DModule_Expression* DModule_DBlock::mutable_next() {
  set_has_next();
  if (next_ == NULL) next_ = new ::DModule_Expression;
  return next_;
}
inline ::DModule_Expression* DModule_DBlock::release_next() {
  clear_has_next();
  ::DModule_Expression* temp = next_;
  next_ = NULL;
  return temp;
}
inline void DModule_DBlock::set_allocated_next(::DModule_Expression* next) {
  delete next_;
  next_ = next;
  if (next) {
    set_has_next();
  } else {
    clear_has_next();
  }
}

// required .DModule.ExitType blockExit = 7;
inline bool DModule_DBlock::has_blockexit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DModule_DBlock::set_has_blockexit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DModule_DBlock::clear_has_blockexit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DModule_DBlock::clear_blockexit() {
  blockexit_ = 0;
  clear_has_blockexit();
}
inline ::DModule_ExitType DModule_DBlock::blockexit() const {
  return static_cast< ::DModule_ExitType >(blockexit_);
}
inline void DModule_DBlock::set_blockexit(::DModule_ExitType value) {
  assert(::DModule_ExitType_IsValid(value));
  set_has_blockexit();
  blockexit_ = value;
}

// -------------------------------------------------------------------

// DModule

// required string fileName = 1;
inline bool DModule::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DModule::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DModule::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DModule::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& DModule::filename() const {
  return *filename_;
}
inline void DModule::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void DModule::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void DModule::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DModule::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* DModule::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DModule::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .DModule.DBlock blocks = 2;
inline int DModule::blocks_size() const {
  return blocks_.size();
}
inline void DModule::clear_blocks() {
  blocks_.Clear();
}
inline const ::DModule_DBlock& DModule::blocks(int index) const {
  return blocks_.Get(index);
}
inline ::DModule_DBlock* DModule::mutable_blocks(int index) {
  return blocks_.Mutable(index);
}
inline ::DModule_DBlock* DModule::add_blocks() {
  return blocks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DModule_DBlock >&
DModule::blocks() const {
  return blocks_;
}
inline ::google::protobuf::RepeatedPtrField< ::DModule_DBlock >*
DModule::mutable_blocks() {
  return &blocks_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DModule_TArchMajor>() {
  return ::DModule_TArchMajor_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DModule_TArchMinor>() {
  return ::DModule_TArchMinor_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DModule_Ops>() {
  return ::DModule_Ops_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DModule_ExType>() {
  return ::DModule_ExType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DModule_ValTy>() {
  return ::DModule_ValTy_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DModule_StType>() {
  return ::DModule_StType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DModule_ExitType>() {
  return ::DModule_ExitType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DModule_MemoryEnd>() {
  return ::DModule_MemoryEnd_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DModule_RegisterClass>() {
  return ::DModule_RegisterClass_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DModule_x86reg_8>() {
  return ::DModule_x86reg_8_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DModule_x86reg_16>() {
  return ::DModule_x86reg_16_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DModule_x86reg_32>() {
  return ::DModule_x86reg_32_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DModule_x86reg_64>() {
  return ::DModule_x86reg_64_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DModule_armreg>() {
  return ::DModule_armreg_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IR_2eproto__INCLUDED
